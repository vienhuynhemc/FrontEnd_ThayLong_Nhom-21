{"ast":null,"code":"import _asyncToGenerator from \"E:/Important/FIT/project-front-end/FrontEnd_ThayLong_Nhom-21/app-chat/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createPannerNodeRendererFactory = (connectAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeGainNode, createNativePannerNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {\n  return () => {\n    const renderedNativeAudioNodes = new WeakMap();\n    let renderedBufferPromise = null;\n\n    const createAudioNode = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (proxy, nativeOfflineAudioContext, trace) {\n        let nativeGainNode = null;\n        let nativePannerNode = getNativeAudioNode(proxy);\n        const commonAudioNodeOptions = {\n          channelCount: nativePannerNode.channelCount,\n          channelCountMode: nativePannerNode.channelCountMode,\n          channelInterpretation: nativePannerNode.channelInterpretation\n        };\n        const commonNativePannerNodeOptions = { ...commonAudioNodeOptions,\n          coneInnerAngle: nativePannerNode.coneInnerAngle,\n          coneOuterAngle: nativePannerNode.coneOuterAngle,\n          coneOuterGain: nativePannerNode.coneOuterGain,\n          distanceModel: nativePannerNode.distanceModel,\n          maxDistance: nativePannerNode.maxDistance,\n          panningModel: nativePannerNode.panningModel,\n          refDistance: nativePannerNode.refDistance,\n          rolloffFactor: nativePannerNode.rolloffFactor\n        }; // If the initially used nativePannerNode was not constructed on the same OfflineAudioContext it needs to be created again.\n\n        const nativePannerNodeIsOwnedByContext = isOwnedByContext(nativePannerNode, nativeOfflineAudioContext); // Bug #124: Safari does not support modifying the orientation and the position with AudioParams.\n\n        if ('bufferSize' in nativePannerNode) {\n          nativeGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions,\n            gain: 1\n          });\n        } else if (!nativePannerNodeIsOwnedByContext) {\n          const options = { ...commonNativePannerNodeOptions,\n            orientationX: nativePannerNode.orientationX.value,\n            orientationY: nativePannerNode.orientationY.value,\n            orientationZ: nativePannerNode.orientationZ.value,\n            positionX: nativePannerNode.positionX.value,\n            positionY: nativePannerNode.positionY.value,\n            positionZ: nativePannerNode.positionZ.value\n          };\n          nativePannerNode = createNativePannerNode(nativeOfflineAudioContext, options);\n        }\n\n        renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeGainNode === null ? nativePannerNode : nativeGainNode);\n\n        if (nativeGainNode !== null) {\n          if (renderedBufferPromise === null) {\n            if (nativeOfflineAudioContextConstructor === null) {\n              throw new Error('Missing the native OfflineAudioContext constructor.');\n            }\n\n            const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(6, // Bug #17: Safari does not yet expose the length.\n            proxy.context.length, nativeOfflineAudioContext.sampleRate);\n            const nativeChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n              channelCount: 1,\n              channelCountMode: 'explicit',\n              channelInterpretation: 'speakers',\n              numberOfInputs: 6\n            });\n            nativeChannelMergerNode.connect(partialOfflineAudioContext.destination);\n            renderedBufferPromise = _asyncToGenerator(function* () {\n              const nativeConstantSourceNodes = yield Promise.all([proxy.orientationX, proxy.orientationY, proxy.orientationZ, proxy.positionX, proxy.positionY, proxy.positionZ].map( /*#__PURE__*/function () {\n                var _ref3 = _asyncToGenerator(function* (audioParam, index) {\n                  const nativeConstantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                    channelCount: 1,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    offset: index === 0 ? 1 : 0\n                  });\n                  yield renderAutomation(partialOfflineAudioContext, audioParam, nativeConstantSourceNode.offset, trace);\n                  return nativeConstantSourceNode;\n                });\n\n                return function (_x4, _x5) {\n                  return _ref3.apply(this, arguments);\n                };\n              }()));\n\n              for (let i = 0; i < 6; i += 1) {\n                nativeConstantSourceNodes[i].connect(nativeChannelMergerNode, 0, i);\n                nativeConstantSourceNodes[i].start(0);\n              }\n\n              return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n            })();\n          }\n\n          const renderedBuffer = yield renderedBufferPromise;\n          const inputGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions,\n            gain: 1\n          });\n          yield renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, inputGainNode, trace);\n          const channelDatas = [];\n\n          for (let i = 0; i < renderedBuffer.numberOfChannels; i += 1) {\n            channelDatas.push(renderedBuffer.getChannelData(i));\n          }\n\n          let lastOrientation = [channelDatas[0][0], channelDatas[1][0], channelDatas[2][0]];\n          let lastPosition = [channelDatas[3][0], channelDatas[4][0], channelDatas[5][0]];\n          let gateGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions,\n            gain: 1\n          });\n          let partialPannerNode = createNativePannerNode(nativeOfflineAudioContext, { ...commonNativePannerNodeOptions,\n            orientationX: lastOrientation[0],\n            orientationY: lastOrientation[1],\n            orientationZ: lastOrientation[2],\n            positionX: lastPosition[0],\n            positionY: lastPosition[1],\n            positionZ: lastPosition[2]\n          });\n          inputGainNode.connect(gateGainNode).connect(partialPannerNode.inputs[0]);\n          partialPannerNode.connect(nativeGainNode);\n\n          for (let i = 128; i < renderedBuffer.length; i += 128) {\n            const orientation = [channelDatas[0][i], channelDatas[1][i], channelDatas[2][i]];\n            const positon = [channelDatas[3][i], channelDatas[4][i], channelDatas[5][i]];\n\n            if (orientation.some((value, index) => value !== lastOrientation[index]) || positon.some((value, index) => value !== lastPosition[index])) {\n              lastOrientation = orientation;\n              lastPosition = positon;\n              const currentTime = i / nativeOfflineAudioContext.sampleRate;\n              gateGainNode.gain.setValueAtTime(0, currentTime);\n              gateGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions,\n                gain: 0\n              });\n              partialPannerNode = createNativePannerNode(nativeOfflineAudioContext, { ...commonNativePannerNodeOptions,\n                orientationX: lastOrientation[0],\n                orientationY: lastOrientation[1],\n                orientationZ: lastOrientation[2],\n                positionX: lastPosition[0],\n                positionY: lastPosition[1],\n                positionZ: lastPosition[2]\n              });\n              gateGainNode.gain.setValueAtTime(1, currentTime);\n              inputGainNode.connect(gateGainNode).connect(partialPannerNode.inputs[0]);\n              partialPannerNode.connect(nativeGainNode);\n            }\n          }\n\n          return nativeGainNode;\n        }\n\n        if (!nativePannerNodeIsOwnedByContext) {\n          yield renderAutomation(nativeOfflineAudioContext, proxy.orientationX, nativePannerNode.orientationX, trace);\n          yield renderAutomation(nativeOfflineAudioContext, proxy.orientationY, nativePannerNode.orientationY, trace);\n          yield renderAutomation(nativeOfflineAudioContext, proxy.orientationZ, nativePannerNode.orientationZ, trace);\n          yield renderAutomation(nativeOfflineAudioContext, proxy.positionX, nativePannerNode.positionX, trace);\n          yield renderAutomation(nativeOfflineAudioContext, proxy.positionY, nativePannerNode.positionY, trace);\n          yield renderAutomation(nativeOfflineAudioContext, proxy.positionZ, nativePannerNode.positionZ, trace);\n        } else {\n          yield connectAudioParam(nativeOfflineAudioContext, proxy.orientationX, nativePannerNode.orientationX, trace);\n          yield connectAudioParam(nativeOfflineAudioContext, proxy.orientationY, nativePannerNode.orientationY, trace);\n          yield connectAudioParam(nativeOfflineAudioContext, proxy.orientationZ, nativePannerNode.orientationZ, trace);\n          yield connectAudioParam(nativeOfflineAudioContext, proxy.positionX, nativePannerNode.positionX, trace);\n          yield connectAudioParam(nativeOfflineAudioContext, proxy.positionY, nativePannerNode.positionY, trace);\n          yield connectAudioParam(nativeOfflineAudioContext, proxy.positionZ, nativePannerNode.positionZ, trace);\n        }\n\n        if (isNativeAudioNodeFaker(nativePannerNode)) {\n          yield renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativePannerNode.inputs[0], trace);\n        } else {\n          yield renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativePannerNode, trace);\n        }\n\n        return nativePannerNode;\n      });\n\n      return function createAudioNode(_x, _x2, _x3) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n\n    return {\n      render(proxy, nativeOfflineAudioContext, trace) {\n        const renderedNativeGainNodeOrNativePannerNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeGainNodeOrNativePannerNode !== undefined) {\n          return Promise.resolve(renderedNativeGainNodeOrNativePannerNode);\n        }\n\n        return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n      }\n\n    };\n  };\n}; //# sourceMappingURL=panner-node-renderer-factory.js.map","map":null,"metadata":{},"sourceType":"module"}