{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Administrator/Desktop/FrontEnd_ThayLong_Nhom-21/app-chat/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { generateUniqueNumber } from 'fast-unique-numbers';\nimport { isSupported } from 'worker-factory';\nimport { worklet } from './worklet/worklet';\n/*\r\n * @todo Explicitly referencing the barrel file seems to be necessary when enabling the\r\n * isolatedModules compiler option.\r\n */\n\nexport * from './interfaces/index';\nexport * from './types/index';\nconst blob = new Blob([worklet], {\n  type: 'application/javascript; charset=utf-8'\n});\nexport const addRecorderAudioWorkletModule = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (addAudioWorkletModule) {\n    const url = URL.createObjectURL(blob);\n\n    try {\n      yield addAudioWorkletModule(url);\n    } finally {\n      URL.revokeObjectURL(url);\n    }\n  });\n\n  return function addRecorderAudioWorkletModule(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\nexport function createRecorderAudioWorkletNode(audioWorkletNodeConstructor, context, options = {}) {\n  const audioWorkletNode = new audioWorkletNodeConstructor(context, 'recorder-audio-worklet-processor', { ...options,\n    channelCountMode: 'explicit',\n    numberOfInputs: 1,\n    numberOfOutputs: 0\n  });\n  const ongoingRequests = new Map();\n\n  const listener = ({\n    data: message\n  }) => {\n    const {\n      id\n    } = message;\n\n    if (id !== null && ongoingRequests.has(id)) {\n      const {\n        reject,\n        resolve\n      } = ongoingRequests.get(id);\n      ongoingRequests.delete(id);\n\n      if (message.error === undefined) {\n        resolve(message.result);\n      } else {\n        reject(new Error(message.error.message));\n      }\n    }\n  };\n\n  const postMessage = (port => {\n    return (message, transferables = []) => {\n      return new Promise((resolve, reject) => {\n        const id = generateUniqueNumber(ongoingRequests);\n        ongoingRequests.set(id, {\n          reject,\n          resolve\n        });\n        port.postMessage({\n          id,\n          ...message\n        }, transferables);\n      });\n    };\n  })(audioWorkletNode.port);\n\n  const removeEventListener = (port => {\n    port.addEventListener('message', listener);\n    port.start();\n    return () => port.removeEventListener('message', listener);\n  })(audioWorkletNode.port);\n\n  let state = 'inactive';\n\n  const changeState = (expectedState, nextState) => {\n    if (state !== expectedState) {\n      throw new Error(`Expected the state to be \"${expectedState}\" but it was \"${state}\".`);\n    }\n\n    state = nextState;\n  };\n\n  Object.defineProperties(audioWorkletNode, {\n    port: {\n      get() {\n        throw new Error(\"The port of a RecorderAudioWorkletNode can't be accessed.\");\n      }\n\n    },\n    record: {\n      get() {\n        return /*#__PURE__*/function () {\n          var _ref2 = _asyncToGenerator(function* (encoderPort) {\n            changeState('inactive', 'recording');\n            return postMessage({\n              method: 'record',\n              params: {\n                encoderPort\n              }\n            }, [encoderPort]);\n          });\n\n          return function (_x2) {\n            return _ref2.apply(this, arguments);\n          };\n        }();\n      }\n\n    },\n    stop: {\n      get() {\n        return /*#__PURE__*/_asyncToGenerator(function* () {\n          changeState('recording', 'stopped');\n\n          try {\n            yield postMessage({\n              method: 'stop'\n            });\n          } finally {\n            removeEventListener();\n          }\n        });\n      }\n\n    }\n  });\n  return audioWorkletNode;\n}\nexport { isSupported }; //# sourceMappingURL=module.js.map","map":{"version":3,"sources":["C:/Users/Administrator/Desktop/FrontEnd_ThayLong_Nhom-21/app-chat/node_modules/recorder-audio-worklet/build/es2019/module.js"],"names":["generateUniqueNumber","isSupported","worklet","blob","Blob","type","addRecorderAudioWorkletModule","addAudioWorkletModule","url","URL","createObjectURL","revokeObjectURL","createRecorderAudioWorkletNode","audioWorkletNodeConstructor","context","options","audioWorkletNode","channelCountMode","numberOfInputs","numberOfOutputs","ongoingRequests","Map","listener","data","message","id","has","reject","resolve","get","delete","error","undefined","result","Error","postMessage","port","transferables","Promise","set","removeEventListener","addEventListener","start","state","changeState","expectedState","nextState","Object","defineProperties","record","encoderPort","method","params","stop"],"mappings":"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","sourcesContent":["import { generateUniqueNumber } from 'fast-unique-numbers';\r\nimport { isSupported } from 'worker-factory';\r\nimport { worklet } from './worklet/worklet';\r\n/*\r\n * @todo Explicitly referencing the barrel file seems to be necessary when enabling the\r\n * isolatedModules compiler option.\r\n */\r\nexport * from './interfaces/index';\r\nexport * from './types/index';\r\nconst blob = new Blob([worklet], { type: 'application/javascript; charset=utf-8' });\r\nexport const addRecorderAudioWorkletModule = async (addAudioWorkletModule) => {\r\n    const url = URL.createObjectURL(blob);\r\n    try {\r\n        await addAudioWorkletModule(url);\r\n    }\r\n    finally {\r\n        URL.revokeObjectURL(url);\r\n    }\r\n};\r\nexport function createRecorderAudioWorkletNode(audioWorkletNodeConstructor, context, options = {}) {\r\n    const audioWorkletNode = new audioWorkletNodeConstructor(context, 'recorder-audio-worklet-processor', {\r\n        ...options,\r\n        channelCountMode: 'explicit',\r\n        numberOfInputs: 1,\r\n        numberOfOutputs: 0\r\n    });\r\n    const ongoingRequests = new Map();\r\n    const listener = ({ data: message }) => {\r\n        const { id } = message;\r\n        if (id !== null && ongoingRequests.has(id)) {\r\n            const { reject, resolve } = ongoingRequests.get(id);\r\n            ongoingRequests.delete(id);\r\n            if (message.error === undefined) {\r\n                resolve(message.result);\r\n            }\r\n            else {\r\n                reject(new Error(message.error.message));\r\n            }\r\n        }\r\n    };\r\n    const postMessage = ((port) => {\r\n        return (message, transferables = []) => {\r\n            return new Promise((resolve, reject) => {\r\n                const id = generateUniqueNumber(ongoingRequests);\r\n                ongoingRequests.set(id, { reject, resolve });\r\n                port.postMessage({ id, ...message }, transferables);\r\n            });\r\n        };\r\n    })(audioWorkletNode.port);\r\n    const removeEventListener = ((port) => {\r\n        port.addEventListener('message', listener);\r\n        port.start();\r\n        return () => port.removeEventListener('message', listener);\r\n    })(audioWorkletNode.port);\r\n    let state = 'inactive';\r\n    const changeState = (expectedState, nextState) => {\r\n        if (state !== expectedState) {\r\n            throw new Error(`Expected the state to be \"${expectedState}\" but it was \"${state}\".`);\r\n        }\r\n        state = nextState;\r\n    };\r\n    Object.defineProperties(audioWorkletNode, {\r\n        port: {\r\n            get() {\r\n                throw new Error(\"The port of a RecorderAudioWorkletNode can't be accessed.\");\r\n            }\r\n        },\r\n        record: {\r\n            get() {\r\n                return async (encoderPort) => {\r\n                    changeState('inactive', 'recording');\r\n                    return postMessage({\r\n                        method: 'record',\r\n                        params: { encoderPort }\r\n                    }, [encoderPort]);\r\n                };\r\n            }\r\n        },\r\n        stop: {\r\n            get() {\r\n                return async () => {\r\n                    changeState('recording', 'stopped');\r\n                    try {\r\n                        await postMessage({ method: 'stop' });\r\n                    }\r\n                    finally {\r\n                        removeEventListener();\r\n                    }\r\n                };\r\n            }\r\n        }\r\n    });\r\n    return audioWorkletNode;\r\n}\r\nexport { isSupported };\r\n//# sourceMappingURL=module.js.map"]},"metadata":{},"sourceType":"module"}