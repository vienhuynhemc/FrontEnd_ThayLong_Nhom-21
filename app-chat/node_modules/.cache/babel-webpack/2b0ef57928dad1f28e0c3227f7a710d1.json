{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Administrator/Desktop/FrontEnd_ThayLong_Nhom-21/app-chat/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { encode, instantiate } from 'media-encoder-host';\nimport { addRecorderAudioWorkletModule, createRecorderAudioWorkletNode } from 'recorder-audio-worklet';\nimport { AudioBuffer, AudioBufferSourceNode, AudioWorkletNode, MediaStreamAudioSourceNode, MinimalAudioContext, addAudioWorkletModule } from 'standardized-audio-context';\nconst ERROR_MESSAGE = 'Missing AudioWorklet support. Maybe this is not running in a secure context.'; // @todo This should live in a separate file.\n\nconst createPromisedAudioNodesEncoderIdAndPort = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (audioBuffer, audioContext, channelCount, mediaStream, mimeType) {\n    const {\n      encoderId,\n      port\n    } = yield instantiate(mimeType, audioContext.sampleRate);\n\n    if (AudioWorkletNode === undefined) {\n      throw new Error(ERROR_MESSAGE);\n    }\n\n    const audioBufferSourceNode = new AudioBufferSourceNode(audioContext, {\n      buffer: audioBuffer\n    });\n    const mediaStreamAudioSourceNode = new MediaStreamAudioSourceNode(audioContext, {\n      mediaStream\n    });\n    const recorderAudioWorkletNode = createRecorderAudioWorkletNode(AudioWorkletNode, audioContext, {\n      channelCount\n    });\n    return {\n      audioBufferSourceNode,\n      encoderId,\n      mediaStreamAudioSourceNode,\n      port,\n      recorderAudioWorkletNode\n    };\n  });\n\n  return function createPromisedAudioNodesEncoderIdAndPort(_x, _x2, _x3, _x4, _x5) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nexport const createWebAudioMediaRecorderFactory = (createBlobEvent, createInvalidModificationError, createInvalidStateError, createNotSupportedError) => {\n  return (eventTarget, mediaStream, mimeType) => {\n    const audioContext = new MinimalAudioContext({\n      latencyHint: 'playback'\n    });\n    const length = Math.max(512, Math.ceil(audioContext.baseLatency * audioContext.sampleRate));\n    const audioBuffer = new AudioBuffer({\n      length,\n      sampleRate: audioContext.sampleRate\n    });\n    const promisedAudioWorkletModule = addRecorderAudioWorkletModule(url => {\n      if (addAudioWorkletModule === undefined) {\n        throw new Error(ERROR_MESSAGE);\n      }\n\n      return addAudioWorkletModule(audioContext, url);\n    });\n    let abortRecording = null;\n    let intervalId = null;\n    let promisedAudioNodesAndEncoderId = null;\n    let promisedPartialRecording = null;\n\n    const dispatchDataAvailableEvent = arrayBuffers => {\n      eventTarget.dispatchEvent(createBlobEvent('dataavailable', {\n        data: new Blob(arrayBuffers, {\n          type: mimeType\n        })\n      }));\n    };\n\n    const requestNextPartialRecording = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(function* (encoderId, timeslice) {\n        dispatchDataAvailableEvent(yield encode(encoderId, timeslice));\n\n        if (promisedAudioNodesAndEncoderId !== null) {\n          promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n        }\n      });\n\n      return function requestNextPartialRecording(_x6, _x7) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n\n    const stop = () => {\n      if (promisedAudioNodesAndEncoderId === null) {\n        return;\n      }\n\n      if (abortRecording !== null) {\n        mediaStream.removeEventListener('addtrack', abortRecording);\n        mediaStream.removeEventListener('removetrack', abortRecording);\n      }\n\n      if (intervalId !== null) {\n        clearTimeout(intervalId);\n      }\n\n      if (promisedPartialRecording !== null) {\n        promisedPartialRecording.catch(() => {\n          /* @todo Only catch the errors caused by a duplicate call to encode. */\n        });\n        promisedPartialRecording = null;\n      }\n\n      promisedAudioNodesAndEncoderId.then( /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator(function* ({\n          encoderId,\n          mediaStreamAudioSourceNode,\n          recorderAudioWorkletNode\n        }) {\n          yield recorderAudioWorkletNode.stop();\n          mediaStreamAudioSourceNode.disconnect(recorderAudioWorkletNode);\n          dispatchDataAvailableEvent(yield encode(encoderId, null));\n          eventTarget.dispatchEvent(new Event('stop'));\n        });\n\n        return function (_x8) {\n          return _ref3.apply(this, arguments);\n        };\n      }());\n      promisedAudioNodesAndEncoderId = null;\n    };\n\n    return {\n      get mimeType() {\n        return mimeType;\n      },\n\n      get state() {\n        return promisedAudioNodesAndEncoderId === null ? 'inactive' : 'recording';\n      },\n\n      start(timeslice) {\n        var _a;\n\n        if (promisedAudioNodesAndEncoderId !== null) {\n          throw createInvalidStateError();\n        }\n\n        if (mediaStream.getVideoTracks().length > 0) {\n          throw createNotSupportedError();\n        }\n\n        const audioTracks = mediaStream.getAudioTracks();\n        const channelCount = audioTracks.length === 0 ? 2 : (_a = audioTracks[0].getSettings().channelCount) !== null && _a !== void 0 ? _a : 2;\n        promisedAudioNodesAndEncoderId = Promise.all([audioContext.resume(), promisedAudioWorkletModule.then(() => createPromisedAudioNodesEncoderIdAndPort(audioBuffer, audioContext, channelCount, mediaStream, mimeType))]).then( /*#__PURE__*/function () {\n          var _ref4 = _asyncToGenerator(function* ([, {\n            audioBufferSourceNode,\n            encoderId,\n            mediaStreamAudioSourceNode,\n            port,\n            recorderAudioWorkletNode\n          }]) {\n            mediaStreamAudioSourceNode.connect(recorderAudioWorkletNode);\n            yield new Promise(resolve => {\n              audioBufferSourceNode.onended = resolve;\n              audioBufferSourceNode.connect(recorderAudioWorkletNode);\n              audioBufferSourceNode.start(audioContext.currentTime + length / audioContext.sampleRate);\n            });\n            audioBufferSourceNode.disconnect(recorderAudioWorkletNode);\n            yield recorderAudioWorkletNode.record(port);\n\n            if (timeslice !== undefined) {\n              promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n            }\n\n            return {\n              encoderId,\n              mediaStreamAudioSourceNode,\n              recorderAudioWorkletNode\n            };\n          });\n\n          return function (_x9) {\n            return _ref4.apply(this, arguments);\n          };\n        }());\n        const tracks = mediaStream.getTracks();\n\n        abortRecording = () => {\n          stop();\n          eventTarget.dispatchEvent(new ErrorEvent('error', {\n            error: createInvalidModificationError()\n          }));\n        };\n\n        mediaStream.addEventListener('addtrack', abortRecording);\n        mediaStream.addEventListener('removetrack', abortRecording);\n        intervalId = setInterval(() => {\n          const currentTracks = mediaStream.getTracks();\n\n          if ((currentTracks.length !== tracks.length || currentTracks.some((track, index) => track !== tracks[index])) && abortRecording !== null) {\n            abortRecording();\n          }\n        }, 1000);\n      },\n\n      stop\n    };\n  };\n}; //# sourceMappingURL=web-audio-media-recorder.js.map","map":{"version":3,"sources":["C:/Users/Administrator/Desktop/FrontEnd_ThayLong_Nhom-21/app-chat/node_modules/extendable-media-recorder/build/es2019/factories/web-audio-media-recorder.js"],"names":["encode","instantiate","addRecorderAudioWorkletModule","createRecorderAudioWorkletNode","AudioBuffer","AudioBufferSourceNode","AudioWorkletNode","MediaStreamAudioSourceNode","MinimalAudioContext","addAudioWorkletModule","ERROR_MESSAGE","createPromisedAudioNodesEncoderIdAndPort","audioBuffer","audioContext","channelCount","mediaStream","mimeType","encoderId","port","sampleRate","undefined","Error","audioBufferSourceNode","buffer","mediaStreamAudioSourceNode","recorderAudioWorkletNode","createWebAudioMediaRecorderFactory","createBlobEvent","createInvalidModificationError","createInvalidStateError","createNotSupportedError","eventTarget","latencyHint","length","Math","max","ceil","baseLatency","promisedAudioWorkletModule","url","abortRecording","intervalId","promisedAudioNodesAndEncoderId","promisedPartialRecording","dispatchDataAvailableEvent","arrayBuffers","dispatchEvent","data","Blob","type","requestNextPartialRecording","timeslice","stop","removeEventListener","clearTimeout","catch","then","disconnect","Event","state","start","_a","getVideoTracks","audioTracks","getAudioTracks","getSettings","Promise","all","resume","connect","resolve","onended","currentTime","record","tracks","getTracks","ErrorEvent","error","addEventListener","setInterval","currentTracks","some","track","index"],"mappings":"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","sourcesContent":["import { encode, instantiate } from 'media-encoder-host';\r\nimport { addRecorderAudioWorkletModule, createRecorderAudioWorkletNode } from 'recorder-audio-worklet';\r\nimport { AudioBuffer, AudioBufferSourceNode, AudioWorkletNode, MediaStreamAudioSourceNode, MinimalAudioContext, addAudioWorkletModule } from 'standardized-audio-context';\r\nconst ERROR_MESSAGE = 'Missing AudioWorklet support. Maybe this is not running in a secure context.';\r\n// @todo This should live in a separate file.\r\nconst createPromisedAudioNodesEncoderIdAndPort = async (audioBuffer, audioContext, channelCount, mediaStream, mimeType) => {\r\n    const { encoderId, port } = await instantiate(mimeType, audioContext.sampleRate);\r\n    if (AudioWorkletNode === undefined) {\r\n        throw new Error(ERROR_MESSAGE);\r\n    }\r\n    const audioBufferSourceNode = new AudioBufferSourceNode(audioContext, { buffer: audioBuffer });\r\n    const mediaStreamAudioSourceNode = new MediaStreamAudioSourceNode(audioContext, { mediaStream });\r\n    const recorderAudioWorkletNode = createRecorderAudioWorkletNode(AudioWorkletNode, audioContext, { channelCount });\r\n    return { audioBufferSourceNode, encoderId, mediaStreamAudioSourceNode, port, recorderAudioWorkletNode };\r\n};\r\nexport const createWebAudioMediaRecorderFactory = (createBlobEvent, createInvalidModificationError, createInvalidStateError, createNotSupportedError) => {\r\n    return (eventTarget, mediaStream, mimeType) => {\r\n        const audioContext = new MinimalAudioContext({ latencyHint: 'playback' });\r\n        const length = Math.max(512, Math.ceil(audioContext.baseLatency * audioContext.sampleRate));\r\n        const audioBuffer = new AudioBuffer({ length, sampleRate: audioContext.sampleRate });\r\n        const promisedAudioWorkletModule = addRecorderAudioWorkletModule((url) => {\r\n            if (addAudioWorkletModule === undefined) {\r\n                throw new Error(ERROR_MESSAGE);\r\n            }\r\n            return addAudioWorkletModule(audioContext, url);\r\n        });\r\n        let abortRecording = null;\r\n        let intervalId = null;\r\n        let promisedAudioNodesAndEncoderId = null;\r\n        let promisedPartialRecording = null;\r\n        const dispatchDataAvailableEvent = (arrayBuffers) => {\r\n            eventTarget.dispatchEvent(createBlobEvent('dataavailable', { data: new Blob(arrayBuffers, { type: mimeType }) }));\r\n        };\r\n        const requestNextPartialRecording = async (encoderId, timeslice) => {\r\n            dispatchDataAvailableEvent(await encode(encoderId, timeslice));\r\n            if (promisedAudioNodesAndEncoderId !== null) {\r\n                promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\r\n            }\r\n        };\r\n        const stop = () => {\r\n            if (promisedAudioNodesAndEncoderId === null) {\r\n                return;\r\n            }\r\n            if (abortRecording !== null) {\r\n                mediaStream.removeEventListener('addtrack', abortRecording);\r\n                mediaStream.removeEventListener('removetrack', abortRecording);\r\n            }\r\n            if (intervalId !== null) {\r\n                clearTimeout(intervalId);\r\n            }\r\n            if (promisedPartialRecording !== null) {\r\n                promisedPartialRecording.catch(() => {\r\n                    /* @todo Only catch the errors caused by a duplicate call to encode. */\r\n                });\r\n                promisedPartialRecording = null;\r\n            }\r\n            promisedAudioNodesAndEncoderId.then(async ({ encoderId, mediaStreamAudioSourceNode, recorderAudioWorkletNode }) => {\r\n                await recorderAudioWorkletNode.stop();\r\n                mediaStreamAudioSourceNode.disconnect(recorderAudioWorkletNode);\r\n                dispatchDataAvailableEvent(await encode(encoderId, null));\r\n                eventTarget.dispatchEvent(new Event('stop'));\r\n            });\r\n            promisedAudioNodesAndEncoderId = null;\r\n        };\r\n        return {\r\n            get mimeType() {\r\n                return mimeType;\r\n            },\r\n            get state() {\r\n                return promisedAudioNodesAndEncoderId === null ? 'inactive' : 'recording';\r\n            },\r\n            start(timeslice) {\r\n                var _a;\r\n                if (promisedAudioNodesAndEncoderId !== null) {\r\n                    throw createInvalidStateError();\r\n                }\r\n                if (mediaStream.getVideoTracks().length > 0) {\r\n                    throw createNotSupportedError();\r\n                }\r\n                const audioTracks = mediaStream.getAudioTracks();\r\n                const channelCount = audioTracks.length === 0 ? 2 : (_a = audioTracks[0].getSettings().channelCount) !== null && _a !== void 0 ? _a : 2;\r\n                promisedAudioNodesAndEncoderId = Promise.all([\r\n                    audioContext.resume(),\r\n                    promisedAudioWorkletModule.then(() => createPromisedAudioNodesEncoderIdAndPort(audioBuffer, audioContext, channelCount, mediaStream, mimeType))\r\n                ]).then(async ([, { audioBufferSourceNode, encoderId, mediaStreamAudioSourceNode, port, recorderAudioWorkletNode }]) => {\r\n                    mediaStreamAudioSourceNode.connect(recorderAudioWorkletNode);\r\n                    await new Promise((resolve) => {\r\n                        audioBufferSourceNode.onended = resolve;\r\n                        audioBufferSourceNode.connect(recorderAudioWorkletNode);\r\n                        audioBufferSourceNode.start(audioContext.currentTime + length / audioContext.sampleRate);\r\n                    });\r\n                    audioBufferSourceNode.disconnect(recorderAudioWorkletNode);\r\n                    await recorderAudioWorkletNode.record(port);\r\n                    if (timeslice !== undefined) {\r\n                        promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\r\n                    }\r\n                    return { encoderId, mediaStreamAudioSourceNode, recorderAudioWorkletNode };\r\n                });\r\n                const tracks = mediaStream.getTracks();\r\n                abortRecording = () => {\r\n                    stop();\r\n                    eventTarget.dispatchEvent(new ErrorEvent('error', { error: createInvalidModificationError() }));\r\n                };\r\n                mediaStream.addEventListener('addtrack', abortRecording);\r\n                mediaStream.addEventListener('removetrack', abortRecording);\r\n                intervalId = setInterval(() => {\r\n                    const currentTracks = mediaStream.getTracks();\r\n                    if ((currentTracks.length !== tracks.length || currentTracks.some((track, index) => track !== tracks[index])) &&\r\n                        abortRecording !== null) {\r\n                        abortRecording();\r\n                    }\r\n                }, 1000);\r\n            },\r\n            stop\r\n        };\r\n    };\r\n};\r\n//# sourceMappingURL=web-audio-media-recorder.js.map"]},"metadata":{},"sourceType":"module"}