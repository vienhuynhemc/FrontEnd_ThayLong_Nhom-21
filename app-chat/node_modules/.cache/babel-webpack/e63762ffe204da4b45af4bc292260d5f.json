{"ast":null,"code":"import _asyncToGenerator from \"E:/Important/FIT/project-front-end/FrontEnd_ThayLong_Nhom-21/app-chat/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { generateUniqueNumber } from 'fast-unique-numbers';\nimport { isSupported } from 'worker-factory';\nimport { worklet } from './worklet/worklet';\n/*\r\n * @todo Explicitly referencing the barrel file seems to be necessary when enabling the\r\n * isolatedModules compiler option.\r\n */\n\nexport * from './interfaces/index';\nexport * from './types/index';\nconst blob = new Blob([worklet], {\n  type: 'application/javascript; charset=utf-8'\n});\nexport const addRecorderAudioWorkletModule = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (addAudioWorkletModule) {\n    const url = URL.createObjectURL(blob);\n\n    try {\n      yield addAudioWorkletModule(url);\n    } finally {\n      URL.revokeObjectURL(url);\n    }\n  });\n\n  return function addRecorderAudioWorkletModule(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\nexport function createRecorderAudioWorkletNode(audioWorkletNodeConstructor, context, options = {}) {\n  const audioWorkletNode = new audioWorkletNodeConstructor(context, 'recorder-audio-worklet-processor', { ...options,\n    channelCountMode: 'explicit',\n    numberOfInputs: 1,\n    numberOfOutputs: 0\n  });\n  const ongoingRequests = new Map();\n\n  const listener = ({\n    data: message\n  }) => {\n    const {\n      id\n    } = message;\n\n    if (id !== null && ongoingRequests.has(id)) {\n      const {\n        reject,\n        resolve\n      } = ongoingRequests.get(id);\n      ongoingRequests.delete(id);\n\n      if (message.error === undefined) {\n        resolve(message.result);\n      } else {\n        reject(new Error(message.error.message));\n      }\n    }\n  };\n\n  const postMessage = (port => {\n    return (message, transferables = []) => {\n      return new Promise((resolve, reject) => {\n        const id = generateUniqueNumber(ongoingRequests);\n        ongoingRequests.set(id, {\n          reject,\n          resolve\n        });\n        port.postMessage({\n          id,\n          ...message\n        }, transferables);\n      });\n    };\n  })(audioWorkletNode.port);\n\n  const removeEventListener = (port => {\n    port.addEventListener('message', listener);\n    port.start();\n    return () => port.removeEventListener('message', listener);\n  })(audioWorkletNode.port);\n\n  let state = 'inactive';\n\n  const changeState = (expectedState, nextState) => {\n    if (state !== expectedState) {\n      throw new Error(`Expected the state to be \"${expectedState}\" but it was \"${state}\".`);\n    }\n\n    state = nextState;\n  };\n\n  Object.defineProperties(audioWorkletNode, {\n    port: {\n      get() {\n        throw new Error(\"The port of a RecorderAudioWorkletNode can't be accessed.\");\n      }\n\n    },\n    record: {\n      get() {\n        return /*#__PURE__*/function () {\n          var _ref2 = _asyncToGenerator(function* (encoderPort) {\n            changeState('inactive', 'recording');\n            return postMessage({\n              method: 'record',\n              params: {\n                encoderPort\n              }\n            }, [encoderPort]);\n          });\n\n          return function (_x2) {\n            return _ref2.apply(this, arguments);\n          };\n        }();\n      }\n\n    },\n    stop: {\n      get() {\n        return /*#__PURE__*/_asyncToGenerator(function* () {\n          changeState('recording', 'stopped');\n\n          try {\n            yield postMessage({\n              method: 'stop'\n            });\n          } finally {\n            removeEventListener();\n          }\n        });\n      }\n\n    }\n  });\n  return audioWorkletNode;\n}\nexport { isSupported }; //# sourceMappingURL=module.js.map","map":null,"metadata":{},"sourceType":"module"}