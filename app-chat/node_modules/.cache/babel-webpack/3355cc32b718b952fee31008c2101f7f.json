{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Administrator/Desktop/FrontEnd_ThayLong_Nhom-21/app-chat/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { encode, instantiate } from 'media-encoder-host';\nimport { MultiBufferDataView } from 'multi-buffer-data-view';\nimport { on } from 'subscribable-things';\nexport const createWebmPcmMediaRecorderFactory = (createBlobEvent, createInvalidModificationError, createNotSupportedError, decodeWebMChunk) => {\n  return (eventTarget, nativeMediaRecorderConstructor, mediaStream, mimeType) => {\n    const nativeMediaRecorder = new nativeMediaRecorderConstructor(mediaStream, {\n      mimeType: 'audio/webm;codecs=pcm'\n    });\n    const audioTracks = mediaStream.getAudioTracks();\n    const channelCount = audioTracks.length === 0 ? undefined : audioTracks[0].getSettings().channelCount;\n    const sampleRate = audioTracks.length === 0 ? undefined : audioTracks[0].getSettings().sampleRate;\n    let promisedPartialRecording = null;\n\n    const dispatchDataAvailableEvent = arrayBuffers => {\n      eventTarget.dispatchEvent(createBlobEvent('dataavailable', {\n        data: new Blob(arrayBuffers, {\n          type: mimeType\n        })\n      }));\n    };\n\n    const requestNextPartialRecording = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (encoderId, timeslice) {\n        dispatchDataAvailableEvent(yield encode(encoderId, timeslice));\n\n        if (nativeMediaRecorder.state !== 'inactive') {\n          promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n        }\n      });\n\n      return function requestNextPartialRecording(_x, _x2) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n\n    const stop = () => {\n      if (nativeMediaRecorder.state === 'inactive') {\n        return;\n      }\n\n      if (promisedPartialRecording !== null) {\n        promisedPartialRecording.catch(() => {\n          /* @todo Only catch the errors caused by a duplicate call to encode. */\n        });\n        promisedPartialRecording = null;\n      }\n\n      nativeMediaRecorder.stop();\n    };\n\n    nativeMediaRecorder.addEventListener('error', () => {\n      stop(); // Bug #3 & 4: Chrome throws an error event without any error.\n\n      eventTarget.dispatchEvent(new ErrorEvent('error', {\n        error: createInvalidModificationError()\n      }));\n    });\n    return {\n      get mimeType() {\n        return mimeType;\n      },\n\n      get state() {\n        return nativeMediaRecorder.state;\n      },\n\n      start(timeslice) {\n        /*\r\n         * Bug #6: Chrome will emit a blob without any data when asked to encode a MediaStream with a video track into an audio\r\n         * codec.\r\n         */\n        if (mediaStream.getVideoTracks().length > 0) {\n          throw createNotSupportedError();\n        }\n\n        if (nativeMediaRecorder.state === 'inactive') {\n          let promisedDataViewElementTypeEncoderIdAndPort = null;\n\n          if (sampleRate !== undefined) {\n            promisedDataViewElementTypeEncoderIdAndPort = instantiate(mimeType, sampleRate);\n          } // Bug #9: Chrome sometimes fires more than one dataavailable event while being inactive.\n\n\n          let pendingInvocations = 0;\n          const removeEventListener = on(nativeMediaRecorder, 'dataavailable')(({\n            data\n          }) => {\n            pendingInvocations += 1;\n\n            if (promisedDataViewElementTypeEncoderIdAndPort !== null) {\n              promisedDataViewElementTypeEncoderIdAndPort = promisedDataViewElementTypeEncoderIdAndPort.then( /*#__PURE__*/function () {\n                var _ref2 = _asyncToGenerator(function* ({\n                  dataView = null,\n                  elementType = null,\n                  encoderId,\n                  port\n                }) {\n                  const multiOrSingleBufferDataView = dataView === null ? new DataView(yield data.arrayBuffer()) : new MultiBufferDataView([...dataView.buffers, yield data.arrayBuffer()], dataView.byteOffset);\n                  const {\n                    currentElementType,\n                    offset,\n                    contents\n                  } = decodeWebMChunk(multiOrSingleBufferDataView, elementType, channelCount);\n                  const buffers = 'buffer' in multiOrSingleBufferDataView ? [multiOrSingleBufferDataView.buffer] : multiOrSingleBufferDataView.buffers;\n                  const remainingDataView = offset < multiOrSingleBufferDataView.byteLength ? new MultiBufferDataView(buffers, multiOrSingleBufferDataView.byteOffset + offset) : null;\n                  contents.forEach(content => port.postMessage(content, content.map(({\n                    buffer\n                  }) => buffer)));\n                  pendingInvocations -= 1;\n\n                  if (pendingInvocations === 0 && nativeMediaRecorder.state === 'inactive') {\n                    encode(encoderId, null).then(arrayBuffers => {\n                      dispatchDataAvailableEvent(arrayBuffers);\n                      eventTarget.dispatchEvent(new Event('stop'));\n                    });\n                    port.postMessage([]);\n                    port.close();\n                    removeEventListener();\n                  }\n\n                  return {\n                    dataView: remainingDataView,\n                    elementType: currentElementType,\n                    encoderId,\n                    port\n                  };\n                });\n\n                return function (_x3) {\n                  return _ref2.apply(this, arguments);\n                };\n              }());\n            }\n          });\n\n          if (promisedDataViewElementTypeEncoderIdAndPort !== null && timeslice !== undefined) {\n            promisedDataViewElementTypeEncoderIdAndPort.then(({\n              encoderId\n            }) => promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice));\n          }\n        }\n\n        nativeMediaRecorder.start(100);\n      },\n\n      stop\n    };\n  };\n}; //# sourceMappingURL=webm-pcm-media-recorder.js.map","map":{"version":3,"sources":["C:/Users/Administrator/Desktop/FrontEnd_ThayLong_Nhom-21/app-chat/node_modules/extendable-media-recorder/build/es2019/factories/webm-pcm-media-recorder.js"],"names":["encode","instantiate","MultiBufferDataView","on","createWebmPcmMediaRecorderFactory","createBlobEvent","createInvalidModificationError","createNotSupportedError","decodeWebMChunk","eventTarget","nativeMediaRecorderConstructor","mediaStream","mimeType","nativeMediaRecorder","audioTracks","getAudioTracks","channelCount","length","undefined","getSettings","sampleRate","promisedPartialRecording","dispatchDataAvailableEvent","arrayBuffers","dispatchEvent","data","Blob","type","requestNextPartialRecording","encoderId","timeslice","state","stop","catch","addEventListener","ErrorEvent","error","start","getVideoTracks","promisedDataViewElementTypeEncoderIdAndPort","pendingInvocations","removeEventListener","then","dataView","elementType","port","multiOrSingleBufferDataView","DataView","arrayBuffer","buffers","byteOffset","currentElementType","offset","contents","buffer","remainingDataView","byteLength","forEach","content","postMessage","map","Event","close"],"mappings":"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","sourcesContent":["import { encode, instantiate } from 'media-encoder-host';\r\nimport { MultiBufferDataView } from 'multi-buffer-data-view';\r\nimport { on } from 'subscribable-things';\r\nexport const createWebmPcmMediaRecorderFactory = (createBlobEvent, createInvalidModificationError, createNotSupportedError, decodeWebMChunk) => {\r\n    return (eventTarget, nativeMediaRecorderConstructor, mediaStream, mimeType) => {\r\n        const nativeMediaRecorder = new nativeMediaRecorderConstructor(mediaStream, { mimeType: 'audio/webm;codecs=pcm' });\r\n        const audioTracks = mediaStream.getAudioTracks();\r\n        const channelCount = audioTracks.length === 0 ? undefined : audioTracks[0].getSettings().channelCount;\r\n        const sampleRate = audioTracks.length === 0 ? undefined : audioTracks[0].getSettings().sampleRate;\r\n        let promisedPartialRecording = null;\r\n        const dispatchDataAvailableEvent = (arrayBuffers) => {\r\n            eventTarget.dispatchEvent(createBlobEvent('dataavailable', { data: new Blob(arrayBuffers, { type: mimeType }) }));\r\n        };\r\n        const requestNextPartialRecording = async (encoderId, timeslice) => {\r\n            dispatchDataAvailableEvent(await encode(encoderId, timeslice));\r\n            if (nativeMediaRecorder.state !== 'inactive') {\r\n                promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\r\n            }\r\n        };\r\n        const stop = () => {\r\n            if (nativeMediaRecorder.state === 'inactive') {\r\n                return;\r\n            }\r\n            if (promisedPartialRecording !== null) {\r\n                promisedPartialRecording.catch(() => {\r\n                    /* @todo Only catch the errors caused by a duplicate call to encode. */\r\n                });\r\n                promisedPartialRecording = null;\r\n            }\r\n            nativeMediaRecorder.stop();\r\n        };\r\n        nativeMediaRecorder.addEventListener('error', () => {\r\n            stop();\r\n            // Bug #3 & 4: Chrome throws an error event without any error.\r\n            eventTarget.dispatchEvent(new ErrorEvent('error', { error: createInvalidModificationError() }));\r\n        });\r\n        return {\r\n            get mimeType() {\r\n                return mimeType;\r\n            },\r\n            get state() {\r\n                return nativeMediaRecorder.state;\r\n            },\r\n            start(timeslice) {\r\n                /*\r\n                 * Bug #6: Chrome will emit a blob without any data when asked to encode a MediaStream with a video track into an audio\r\n                 * codec.\r\n                 */\r\n                if (mediaStream.getVideoTracks().length > 0) {\r\n                    throw createNotSupportedError();\r\n                }\r\n                if (nativeMediaRecorder.state === 'inactive') {\r\n                    let promisedDataViewElementTypeEncoderIdAndPort = null;\r\n                    if (sampleRate !== undefined) {\r\n                        promisedDataViewElementTypeEncoderIdAndPort = instantiate(mimeType, sampleRate);\r\n                    }\r\n                    // Bug #9: Chrome sometimes fires more than one dataavailable event while being inactive.\r\n                    let pendingInvocations = 0;\r\n                    const removeEventListener = on(nativeMediaRecorder, 'dataavailable')(({ data }) => {\r\n                        pendingInvocations += 1;\r\n                        if (promisedDataViewElementTypeEncoderIdAndPort !== null) {\r\n                            promisedDataViewElementTypeEncoderIdAndPort = promisedDataViewElementTypeEncoderIdAndPort.then(async ({ dataView = null, elementType = null, encoderId, port }) => {\r\n                                const multiOrSingleBufferDataView = dataView === null\r\n                                    ? new DataView(await data.arrayBuffer())\r\n                                    : new MultiBufferDataView([...dataView.buffers, await data.arrayBuffer()], dataView.byteOffset);\r\n                                const { currentElementType, offset, contents } = decodeWebMChunk(multiOrSingleBufferDataView, elementType, channelCount);\r\n                                const buffers = 'buffer' in multiOrSingleBufferDataView\r\n                                    ? [multiOrSingleBufferDataView.buffer]\r\n                                    : multiOrSingleBufferDataView.buffers;\r\n                                const remainingDataView = offset < multiOrSingleBufferDataView.byteLength\r\n                                    ? new MultiBufferDataView(buffers, multiOrSingleBufferDataView.byteOffset + offset)\r\n                                    : null;\r\n                                contents.forEach((content) => port.postMessage(content, content.map(({ buffer }) => buffer)));\r\n                                pendingInvocations -= 1;\r\n                                if (pendingInvocations === 0 && nativeMediaRecorder.state === 'inactive') {\r\n                                    encode(encoderId, null).then((arrayBuffers) => {\r\n                                        dispatchDataAvailableEvent(arrayBuffers);\r\n                                        eventTarget.dispatchEvent(new Event('stop'));\r\n                                    });\r\n                                    port.postMessage([]);\r\n                                    port.close();\r\n                                    removeEventListener();\r\n                                }\r\n                                return { dataView: remainingDataView, elementType: currentElementType, encoderId, port };\r\n                            });\r\n                        }\r\n                    });\r\n                    if (promisedDataViewElementTypeEncoderIdAndPort !== null && timeslice !== undefined) {\r\n                        promisedDataViewElementTypeEncoderIdAndPort.then(({ encoderId }) => (promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice)));\r\n                    }\r\n                }\r\n                nativeMediaRecorder.start(100);\r\n            },\r\n            stop\r\n        };\r\n    };\r\n};\r\n//# sourceMappingURL=webm-pcm-media-recorder.js.map"]},"metadata":{},"sourceType":"module"}