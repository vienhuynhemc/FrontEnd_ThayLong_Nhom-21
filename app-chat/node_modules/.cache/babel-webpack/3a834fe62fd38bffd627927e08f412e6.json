{"ast":null,"code":"import _asyncToGenerator from \"E:/Important/FIT/project-front-end/FrontEnd_ThayLong_Nhom-21/app-chat/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioWorkletProcessor } from '../helpers/get-audio-worklet-processor';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\n\nconst processBuffer = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (proxy, renderedBuffer, nativeOfflineAudioContext, options, outputChannelCount, processorConstructor, exposeCurrentFrameAndCurrentTime) {\n    // Ceil the length to the next full render quantum.\n    // Bug #17: Safari does not yet expose the length.\n    const length = renderedBuffer === null ? Math.ceil(proxy.context.length / 128) * 128 : renderedBuffer.length;\n    const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n    const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n    const processedBuffer = numberOfOutputChannels === 0 ? null : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);\n\n    if (processorConstructor === undefined) {\n      throw new Error('Missing the processor constructor.');\n    }\n\n    const audioNodeConnections = getAudioNodeConnections(proxy);\n    const audioWorkletProcessor = yield getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);\n    const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n    const outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);\n    const parameters = Array.from(proxy.parameters.keys()).reduce((prmtrs, name) => ({ ...prmtrs,\n      [name]: new Float32Array(128)\n    }), {});\n\n    for (let i = 0; i < length; i += 128) {\n      if (options.numberOfInputs > 0 && renderedBuffer !== null) {\n        for (let j = 0; j < options.numberOfInputs; j += 1) {\n          for (let k = 0; k < options.channelCount; k += 1) {\n            copyFromChannel(renderedBuffer, inputs[j], k, k, i);\n          }\n        }\n      }\n\n      if (processorConstructor.parameterDescriptors !== undefined && renderedBuffer !== null) {\n        processorConstructor.parameterDescriptors.forEach(({\n          name\n        }, index) => {\n          copyFromChannel(renderedBuffer, parameters, name, numberOfInputChannels + index, i);\n        });\n      }\n\n      for (let j = 0; j < options.numberOfInputs; j += 1) {\n        for (let k = 0; k < outputChannelCount[j]; k += 1) {\n          // The byteLength will be 0 when the ArrayBuffer was transferred.\n          if (outputs[j][k].byteLength === 0) {\n            outputs[j][k] = new Float32Array(128);\n          }\n        }\n      }\n\n      try {\n        const potentiallyEmptyInputs = inputs.map((input, index) => {\n          if (audioNodeConnections.activeInputs[index].size === 0) {\n            return [];\n          }\n\n          return input;\n        });\n        const activeSourceFlag = exposeCurrentFrameAndCurrentTime(i / nativeOfflineAudioContext.sampleRate, nativeOfflineAudioContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\n\n        if (processedBuffer !== null) {\n          for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n            for (let k = 0; k < outputChannelCount[j]; k += 1) {\n              copyToChannel(processedBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n            }\n\n            outputChannelSplitterNodeOutput += outputChannelCount[j];\n          }\n        }\n\n        if (!activeSourceFlag) {\n          break;\n        }\n      } catch (error) {\n        proxy.dispatchEvent(new ErrorEvent('processorerror', {\n          colno: error.colno,\n          filename: error.filename,\n          lineno: error.lineno,\n          message: error.message\n        }));\n        break;\n      }\n    }\n\n    return processedBuffer;\n  });\n\n  return function processBuffer(_x, _x2, _x3, _x4, _x5, _x6, _x7) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nexport const createAudioWorkletNodeRendererFactory = (connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, deleteUnrenderedAudioWorkletNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {\n  return (name, options, processorConstructor) => {\n    const renderedNativeAudioNodes = new WeakMap();\n    let processedBufferPromise = null;\n\n    const createAudioNode = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(function* (proxy, nativeOfflineAudioContext, trace) {\n        let nativeAudioWorkletNode = getNativeAudioNode(proxy);\n        let nativeOutputNodes = null;\n        const nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext);\n        const outputChannelCount = Array.isArray(options.outputChannelCount) ? options.outputChannelCount : Array.from(options.outputChannelCount); // Bug #61: Only Chrome, Edge, Firefox & Opera have an implementation of the AudioWorkletNode yet.\n\n        if (nativeAudioWorkletNodeConstructor === null) {\n          const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n          const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, {\n            channelCount: Math.max(1, numberOfOutputChannels),\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            numberOfOutputs: Math.max(1, numberOfOutputChannels)\n          });\n          const outputChannelMergerNodes = [];\n\n          for (let i = 0; i < proxy.numberOfOutputs; i += 1) {\n            outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeOfflineAudioContext, {\n              channelCount: 1,\n              channelCountMode: 'explicit',\n              channelInterpretation: 'speakers',\n              numberOfInputs: outputChannelCount[i]\n            }));\n          }\n\n          const outputGainNode = createNativeGainNode(nativeOfflineAudioContext, {\n            channelCount: options.channelCount,\n            channelCountMode: options.channelCountMode,\n            channelInterpretation: options.channelInterpretation,\n            gain: 1\n          });\n          outputGainNode.connect = connectMultipleOutputs.bind(null, outputChannelMergerNodes);\n          outputGainNode.disconnect = disconnectMultipleOutputs.bind(null, outputChannelMergerNodes);\n          nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];\n        } else if (!nativeAudioWorkletNodeIsOwnedByContext) {\n          nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeOfflineAudioContext, name);\n        }\n\n        renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeOutputNodes === null ? nativeAudioWorkletNode : nativeOutputNodes[2]);\n\n        if (nativeOutputNodes !== null) {\n          if (processedBufferPromise === null) {\n            if (processorConstructor === undefined) {\n              throw new Error('Missing the processor constructor.');\n            }\n\n            if (nativeOfflineAudioContextConstructor === null) {\n              throw new Error('Missing the native OfflineAudioContext constructor.');\n            } // Bug #47: The AudioDestinationNode in Safari gets not initialized correctly.\n\n\n            const numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;\n            const numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n            const numberOfChannels = numberOfInputChannels + numberOfParameters;\n\n            const renderBuffer = /*#__PURE__*/function () {\n              var _ref3 = _asyncToGenerator(function* () {\n                const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(numberOfChannels, // Ceil the length to the next full render quantum.\n                // Bug #17: Safari does not yet expose the length.\n                Math.ceil(proxy.context.length / 128) * 128, nativeOfflineAudioContext.sampleRate);\n                const gainNodes = [];\n                const inputChannelSplitterNodes = [];\n\n                for (let i = 0; i < options.numberOfInputs; i += 1) {\n                  gainNodes.push(createNativeGainNode(partialOfflineAudioContext, {\n                    channelCount: options.channelCount,\n                    channelCountMode: options.channelCountMode,\n                    channelInterpretation: options.channelInterpretation,\n                    gain: 1\n                  }));\n                  inputChannelSplitterNodes.push(createNativeChannelSplitterNode(partialOfflineAudioContext, {\n                    channelCount: options.channelCount,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    numberOfOutputs: options.channelCount\n                  }));\n                }\n\n                const constantSourceNodes = yield Promise.all(Array.from(proxy.parameters.values()).map( /*#__PURE__*/function () {\n                  var _ref4 = _asyncToGenerator(function* (audioParam) {\n                    const constantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                      channelCount: 1,\n                      channelCountMode: 'explicit',\n                      channelInterpretation: 'discrete',\n                      offset: audioParam.value\n                    });\n                    yield renderAutomation(partialOfflineAudioContext, audioParam, constantSourceNode.offset, trace);\n                    return constantSourceNode;\n                  });\n\n                  return function (_x11) {\n                    return _ref4.apply(this, arguments);\n                  };\n                }()));\n                const inputChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n                  channelCount: 1,\n                  channelCountMode: 'explicit',\n                  channelInterpretation: 'speakers',\n                  numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n                });\n\n                for (let i = 0; i < options.numberOfInputs; i += 1) {\n                  gainNodes[i].connect(inputChannelSplitterNodes[i]);\n\n                  for (let j = 0; j < options.channelCount; j += 1) {\n                    inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n                  }\n                }\n\n                for (const [index, constantSourceNode] of constantSourceNodes.entries()) {\n                  constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                  constantSourceNode.start(0);\n                }\n\n                inputChannelMergerNode.connect(partialOfflineAudioContext.destination);\n                yield Promise.all(gainNodes.map(gainNode => renderInputsOfAudioNode(proxy, partialOfflineAudioContext, gainNode, trace)));\n                return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n              });\n\n              return function renderBuffer() {\n                return _ref3.apply(this, arguments);\n              };\n            }();\n\n            processedBufferPromise = processBuffer(proxy, numberOfChannels === 0 ? null : yield renderBuffer(), nativeOfflineAudioContext, options, outputChannelCount, processorConstructor, exposeCurrentFrameAndCurrentTime);\n          }\n\n          const processedBuffer = yield processedBufferPromise;\n          const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {\n            buffer: null,\n            channelCount: 2,\n            channelCountMode: 'max',\n            channelInterpretation: 'speakers',\n            loop: false,\n            loopEnd: 0,\n            loopStart: 0,\n            playbackRate: 1\n          });\n          const [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode] = nativeOutputNodes;\n\n          if (processedBuffer !== null) {\n            audioBufferSourceNode.buffer = processedBuffer;\n            audioBufferSourceNode.start(0);\n          }\n\n          audioBufferSourceNode.connect(outputChannelSplitterNode);\n\n          for (let i = 0, outputChannelSplitterNodeOutput = 0; i < proxy.numberOfOutputs; i += 1) {\n            const outputChannelMergerNode = outputChannelMergerNodes[i];\n\n            for (let j = 0; j < outputChannelCount[i]; j += 1) {\n              outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n            }\n\n            outputChannelSplitterNodeOutput += outputChannelCount[i];\n          }\n\n          return outputGainNode;\n        }\n\n        if (!nativeAudioWorkletNodeIsOwnedByContext) {\n          for (const [nm, audioParam] of proxy.parameters.entries()) {\n            yield renderAutomation(nativeOfflineAudioContext, audioParam, // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n            nativeAudioWorkletNode.parameters.get(nm), trace);\n          }\n        } else {\n          for (const [nm, audioParam] of proxy.parameters.entries()) {\n            yield connectAudioParam(nativeOfflineAudioContext, audioParam, // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n            nativeAudioWorkletNode.parameters.get(nm), trace);\n          }\n        }\n\n        yield renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode, trace);\n        return nativeAudioWorkletNode;\n      });\n\n      return function createAudioNode(_x8, _x9, _x10) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n\n    return {\n      render(proxy, nativeOfflineAudioContext, trace) {\n        deleteUnrenderedAudioWorkletNode(nativeOfflineAudioContext, proxy);\n        const renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeAudioWorkletNodeOrGainNode !== undefined) {\n          return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);\n        }\n\n        return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n      }\n\n    };\n  };\n}; //# sourceMappingURL=audio-worklet-node-renderer-factory.js.map","map":{"version":3,"sources":["E:/Important/FIT/project-front-end/FrontEnd_ThayLong_Nhom-21/app-chat/node_modules/standardized-audio-context/build/es2019/factories/audio-worklet-node-renderer-factory.js"],"names":["copyFromChannel","copyToChannel","createNestedArrays","getAudioNodeConnections","getAudioWorkletProcessor","isOwnedByContext","processBuffer","proxy","renderedBuffer","nativeOfflineAudioContext","options","outputChannelCount","processorConstructor","exposeCurrentFrameAndCurrentTime","length","Math","ceil","context","numberOfInputChannels","channelCount","numberOfInputs","numberOfOutputChannels","reduce","sum","value","processedBuffer","createBuffer","sampleRate","undefined","Error","audioNodeConnections","audioWorkletProcessor","inputs","outputs","numberOfOutputs","parameters","Array","from","keys","prmtrs","name","Float32Array","i","j","k","parameterDescriptors","forEach","index","byteLength","potentiallyEmptyInputs","map","input","activeInputs","size","activeSourceFlag","process","outputChannelSplitterNodeOutput","error","dispatchEvent","ErrorEvent","colno","filename","lineno","message","createAudioWorkletNodeRendererFactory","connectAudioParam","connectMultipleOutputs","createNativeAudioBufferSourceNode","createNativeChannelMergerNode","createNativeChannelSplitterNode","createNativeConstantSourceNode","createNativeGainNode","deleteUnrenderedAudioWorkletNode","disconnectMultipleOutputs","getNativeAudioNode","nativeAudioWorkletNodeConstructor","nativeOfflineAudioContextConstructor","renderAutomation","renderInputsOfAudioNode","renderNativeOfflineAudioContext","renderedNativeAudioNodes","WeakMap","processedBufferPromise","createAudioNode","trace","nativeAudioWorkletNode","nativeOutputNodes","nativeAudioWorkletNodeIsOwnedByContext","isArray","outputChannelSplitterNode","max","channelCountMode","channelInterpretation","outputChannelMergerNodes","push","outputGainNode","gain","connect","bind","disconnect","set","numberOfParameters","numberOfChannels","renderBuffer","partialOfflineAudioContext","gainNodes","inputChannelSplitterNodes","constantSourceNodes","Promise","all","values","audioParam","constantSourceNode","offset","inputChannelMergerNode","entries","start","destination","gainNode","audioBufferSourceNode","buffer","loop","loopEnd","loopStart","playbackRate","outputChannelMergerNode","nm","get","render","renderedNativeAudioWorkletNodeOrGainNode","resolve"],"mappings":"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","sourcesContent":["import { copyFromChannel } from '../helpers/copy-from-channel';\r\nimport { copyToChannel } from '../helpers/copy-to-channel';\r\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\r\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\r\nimport { getAudioWorkletProcessor } from '../helpers/get-audio-worklet-processor';\r\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\r\nconst processBuffer = async (proxy, renderedBuffer, nativeOfflineAudioContext, options, outputChannelCount, processorConstructor, exposeCurrentFrameAndCurrentTime) => {\r\n    // Ceil the length to the next full render quantum.\r\n    // Bug #17: Safari does not yet expose the length.\r\n    const length = renderedBuffer === null ? Math.ceil(proxy.context.length / 128) * 128 : renderedBuffer.length;\r\n    const numberOfInputChannels = options.channelCount * options.numberOfInputs;\r\n    const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\r\n    const processedBuffer = numberOfOutputChannels === 0\r\n        ? null\r\n        : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);\r\n    if (processorConstructor === undefined) {\r\n        throw new Error('Missing the processor constructor.');\r\n    }\r\n    const audioNodeConnections = getAudioNodeConnections(proxy);\r\n    const audioWorkletProcessor = await getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);\r\n    const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\r\n    const outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);\r\n    const parameters = Array.from(proxy.parameters.keys()).reduce((prmtrs, name) => ({ ...prmtrs, [name]: new Float32Array(128) }), {});\r\n    for (let i = 0; i < length; i += 128) {\r\n        if (options.numberOfInputs > 0 && renderedBuffer !== null) {\r\n            for (let j = 0; j < options.numberOfInputs; j += 1) {\r\n                for (let k = 0; k < options.channelCount; k += 1) {\r\n                    copyFromChannel(renderedBuffer, inputs[j], k, k, i);\r\n                }\r\n            }\r\n        }\r\n        if (processorConstructor.parameterDescriptors !== undefined && renderedBuffer !== null) {\r\n            processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\r\n                copyFromChannel(renderedBuffer, parameters, name, numberOfInputChannels + index, i);\r\n            });\r\n        }\r\n        for (let j = 0; j < options.numberOfInputs; j += 1) {\r\n            for (let k = 0; k < outputChannelCount[j]; k += 1) {\r\n                // The byteLength will be 0 when the ArrayBuffer was transferred.\r\n                if (outputs[j][k].byteLength === 0) {\r\n                    outputs[j][k] = new Float32Array(128);\r\n                }\r\n            }\r\n        }\r\n        try {\r\n            const potentiallyEmptyInputs = inputs.map((input, index) => {\r\n                if (audioNodeConnections.activeInputs[index].size === 0) {\r\n                    return [];\r\n                }\r\n                return input;\r\n            });\r\n            const activeSourceFlag = exposeCurrentFrameAndCurrentTime(i / nativeOfflineAudioContext.sampleRate, nativeOfflineAudioContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\r\n            if (processedBuffer !== null) {\r\n                for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\r\n                    for (let k = 0; k < outputChannelCount[j]; k += 1) {\r\n                        copyToChannel(processedBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\r\n                    }\r\n                    outputChannelSplitterNodeOutput += outputChannelCount[j];\r\n                }\r\n            }\r\n            if (!activeSourceFlag) {\r\n                break;\r\n            }\r\n        }\r\n        catch (error) {\r\n            proxy.dispatchEvent(new ErrorEvent('processorerror', {\r\n                colno: error.colno,\r\n                filename: error.filename,\r\n                lineno: error.lineno,\r\n                message: error.message\r\n            }));\r\n            break;\r\n        }\r\n    }\r\n    return processedBuffer;\r\n};\r\nexport const createAudioWorkletNodeRendererFactory = (connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, deleteUnrenderedAudioWorkletNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {\r\n    return (name, options, processorConstructor) => {\r\n        const renderedNativeAudioNodes = new WeakMap();\r\n        let processedBufferPromise = null;\r\n        const createAudioNode = async (proxy, nativeOfflineAudioContext, trace) => {\r\n            let nativeAudioWorkletNode = getNativeAudioNode(proxy);\r\n            let nativeOutputNodes = null;\r\n            const nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext);\r\n            const outputChannelCount = Array.isArray(options.outputChannelCount)\r\n                ? options.outputChannelCount\r\n                : Array.from(options.outputChannelCount);\r\n            // Bug #61: Only Chrome, Edge, Firefox & Opera have an implementation of the AudioWorkletNode yet.\r\n            if (nativeAudioWorkletNodeConstructor === null) {\r\n                const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\r\n                const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, {\r\n                    channelCount: Math.max(1, numberOfOutputChannels),\r\n                    channelCountMode: 'explicit',\r\n                    channelInterpretation: 'discrete',\r\n                    numberOfOutputs: Math.max(1, numberOfOutputChannels)\r\n                });\r\n                const outputChannelMergerNodes = [];\r\n                for (let i = 0; i < proxy.numberOfOutputs; i += 1) {\r\n                    outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeOfflineAudioContext, {\r\n                        channelCount: 1,\r\n                        channelCountMode: 'explicit',\r\n                        channelInterpretation: 'speakers',\r\n                        numberOfInputs: outputChannelCount[i]\r\n                    }));\r\n                }\r\n                const outputGainNode = createNativeGainNode(nativeOfflineAudioContext, {\r\n                    channelCount: options.channelCount,\r\n                    channelCountMode: options.channelCountMode,\r\n                    channelInterpretation: options.channelInterpretation,\r\n                    gain: 1\r\n                });\r\n                outputGainNode.connect = connectMultipleOutputs.bind(null, outputChannelMergerNodes);\r\n                outputGainNode.disconnect = disconnectMultipleOutputs.bind(null, outputChannelMergerNodes);\r\n                nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];\r\n            }\r\n            else if (!nativeAudioWorkletNodeIsOwnedByContext) {\r\n                nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeOfflineAudioContext, name);\r\n            }\r\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeOutputNodes === null ? nativeAudioWorkletNode : nativeOutputNodes[2]);\r\n            if (nativeOutputNodes !== null) {\r\n                if (processedBufferPromise === null) {\r\n                    if (processorConstructor === undefined) {\r\n                        throw new Error('Missing the processor constructor.');\r\n                    }\r\n                    if (nativeOfflineAudioContextConstructor === null) {\r\n                        throw new Error('Missing the native OfflineAudioContext constructor.');\r\n                    }\r\n                    // Bug #47: The AudioDestinationNode in Safari gets not initialized correctly.\r\n                    const numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;\r\n                    const numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\r\n                    const numberOfChannels = numberOfInputChannels + numberOfParameters;\r\n                    const renderBuffer = async () => {\r\n                        const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(numberOfChannels, \r\n                        // Ceil the length to the next full render quantum.\r\n                        // Bug #17: Safari does not yet expose the length.\r\n                        Math.ceil(proxy.context.length / 128) * 128, nativeOfflineAudioContext.sampleRate);\r\n                        const gainNodes = [];\r\n                        const inputChannelSplitterNodes = [];\r\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\r\n                            gainNodes.push(createNativeGainNode(partialOfflineAudioContext, {\r\n                                channelCount: options.channelCount,\r\n                                channelCountMode: options.channelCountMode,\r\n                                channelInterpretation: options.channelInterpretation,\r\n                                gain: 1\r\n                            }));\r\n                            inputChannelSplitterNodes.push(createNativeChannelSplitterNode(partialOfflineAudioContext, {\r\n                                channelCount: options.channelCount,\r\n                                channelCountMode: 'explicit',\r\n                                channelInterpretation: 'discrete',\r\n                                numberOfOutputs: options.channelCount\r\n                            }));\r\n                        }\r\n                        const constantSourceNodes = await Promise.all(Array.from(proxy.parameters.values()).map(async (audioParam) => {\r\n                            const constantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\r\n                                channelCount: 1,\r\n                                channelCountMode: 'explicit',\r\n                                channelInterpretation: 'discrete',\r\n                                offset: audioParam.value\r\n                            });\r\n                            await renderAutomation(partialOfflineAudioContext, audioParam, constantSourceNode.offset, trace);\r\n                            return constantSourceNode;\r\n                        }));\r\n                        const inputChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\r\n                            channelCount: 1,\r\n                            channelCountMode: 'explicit',\r\n                            channelInterpretation: 'speakers',\r\n                            numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\r\n                        });\r\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\r\n                            gainNodes[i].connect(inputChannelSplitterNodes[i]);\r\n                            for (let j = 0; j < options.channelCount; j += 1) {\r\n                                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\r\n                            }\r\n                        }\r\n                        for (const [index, constantSourceNode] of constantSourceNodes.entries()) {\r\n                            constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\r\n                            constantSourceNode.start(0);\r\n                        }\r\n                        inputChannelMergerNode.connect(partialOfflineAudioContext.destination);\r\n                        await Promise.all(gainNodes.map((gainNode) => renderInputsOfAudioNode(proxy, partialOfflineAudioContext, gainNode, trace)));\r\n                        return renderNativeOfflineAudioContext(partialOfflineAudioContext);\r\n                    };\r\n                    processedBufferPromise = processBuffer(proxy, numberOfChannels === 0 ? null : await renderBuffer(), nativeOfflineAudioContext, options, outputChannelCount, processorConstructor, exposeCurrentFrameAndCurrentTime);\r\n                }\r\n                const processedBuffer = await processedBufferPromise;\r\n                const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {\r\n                    buffer: null,\r\n                    channelCount: 2,\r\n                    channelCountMode: 'max',\r\n                    channelInterpretation: 'speakers',\r\n                    loop: false,\r\n                    loopEnd: 0,\r\n                    loopStart: 0,\r\n                    playbackRate: 1\r\n                });\r\n                const [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode] = nativeOutputNodes;\r\n                if (processedBuffer !== null) {\r\n                    audioBufferSourceNode.buffer = processedBuffer;\r\n                    audioBufferSourceNode.start(0);\r\n                }\r\n                audioBufferSourceNode.connect(outputChannelSplitterNode);\r\n                for (let i = 0, outputChannelSplitterNodeOutput = 0; i < proxy.numberOfOutputs; i += 1) {\r\n                    const outputChannelMergerNode = outputChannelMergerNodes[i];\r\n                    for (let j = 0; j < outputChannelCount[i]; j += 1) {\r\n                        outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\r\n                    }\r\n                    outputChannelSplitterNodeOutput += outputChannelCount[i];\r\n                }\r\n                return outputGainNode;\r\n            }\r\n            if (!nativeAudioWorkletNodeIsOwnedByContext) {\r\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\r\n                    await renderAutomation(nativeOfflineAudioContext, audioParam, \r\n                    // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\r\n                    nativeAudioWorkletNode.parameters.get(nm), trace);\r\n                }\r\n            }\r\n            else {\r\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\r\n                    await connectAudioParam(nativeOfflineAudioContext, audioParam, \r\n                    // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\r\n                    nativeAudioWorkletNode.parameters.get(nm), trace);\r\n                }\r\n            }\r\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode, trace);\r\n            return nativeAudioWorkletNode;\r\n        };\r\n        return {\r\n            render(proxy, nativeOfflineAudioContext, trace) {\r\n                deleteUnrenderedAudioWorkletNode(nativeOfflineAudioContext, proxy);\r\n                const renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\r\n                if (renderedNativeAudioWorkletNodeOrGainNode !== undefined) {\r\n                    return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);\r\n                }\r\n                return createAudioNode(proxy, nativeOfflineAudioContext, trace);\r\n            }\r\n        };\r\n    };\r\n};\r\n//# sourceMappingURL=audio-worklet-node-renderer-factory.js.map"]},"metadata":{},"sourceType":"module"}