{"ast":null,"code":"'use strict';\n\nconst EE = require('events');\n\nconst Stream = require('stream');\n\nconst Yallist = require('yallist');\n\nconst SD = require('string_decoder').StringDecoder;\n\nconst EOF = Symbol('EOF');\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd');\nconst EMITTED_END = Symbol('emittedEnd');\nconst EMITTING_END = Symbol('emittingEnd');\nconst CLOSED = Symbol('closed');\nconst READ = Symbol('read');\nconst FLUSH = Symbol('flush');\nconst FLUSHCHUNK = Symbol('flushChunk');\nconst ENCODING = Symbol('encoding');\nconst DECODER = Symbol('decoder');\nconst FLOWING = Symbol('flowing');\nconst PAUSED = Symbol('paused');\nconst RESUME = Symbol('resume');\nconst BUFFERLENGTH = Symbol('bufferLength');\nconst BUFFERPUSH = Symbol('bufferPush');\nconst BUFFERSHIFT = Symbol('bufferShift');\nconst OBJECTMODE = Symbol('objectMode');\nconst DESTROYED = Symbol('destroyed'); // TODO remove when Node v8 support drops\n\nconst doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== '1';\nconst ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol('asyncIterator not implemented');\nconst ITERATOR = doIter && Symbol.iterator || Symbol('iterator not implemented'); // events that mean 'the stream is over'\n// these are treated specially, and re-emitted\n// if they are listened for after emitting.\n\nconst isEndish = ev => ev === 'end' || ev === 'finish' || ev === 'prefinish';\n\nconst isArrayBuffer = b => b instanceof ArrayBuffer || typeof b === 'object' && b.constructor && b.constructor.name === 'ArrayBuffer' && b.byteLength >= 0;\n\nconst isArrayBufferView = b => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);\n\nmodule.exports = class Minipass extends Stream {\n  constructor(options) {\n    super();\n    this[FLOWING] = false; // whether we're explicitly paused\n\n    this[PAUSED] = false;\n    this.pipes = new Yallist();\n    this.buffer = new Yallist();\n    this[OBJECTMODE] = options && options.objectMode || false;\n    if (this[OBJECTMODE]) this[ENCODING] = null;else this[ENCODING] = options && options.encoding || null;\n    if (this[ENCODING] === 'buffer') this[ENCODING] = null;\n    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;\n    this[EOF] = false;\n    this[EMITTED_END] = false;\n    this[EMITTING_END] = false;\n    this[CLOSED] = false;\n    this.writable = true;\n    this.readable = true;\n    this[BUFFERLENGTH] = 0;\n    this[DESTROYED] = false;\n  }\n\n  get bufferLength() {\n    return this[BUFFERLENGTH];\n  }\n\n  get encoding() {\n    return this[ENCODING];\n  }\n\n  set encoding(enc) {\n    if (this[OBJECTMODE]) throw new Error('cannot set encoding in objectMode');\n    if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH])) throw new Error('cannot change encoding');\n\n    if (this[ENCODING] !== enc) {\n      this[DECODER] = enc ? new SD(enc) : null;\n      if (this.buffer.length) this.buffer = this.buffer.map(chunk => this[DECODER].write(chunk));\n    }\n\n    this[ENCODING] = enc;\n  }\n\n  setEncoding(enc) {\n    this.encoding = enc;\n  }\n\n  get objectMode() {\n    return this[OBJECTMODE];\n  }\n\n  set objectMode(om) {\n    this[OBJECTMODE] = this[OBJECTMODE] || !!om;\n  }\n\n  write(chunk, encoding, cb) {\n    if (this[EOF]) throw new Error('write after end');\n\n    if (this[DESTROYED]) {\n      this.emit('error', Object.assign(new Error('Cannot call write after a stream was destroyed'), {\n        code: 'ERR_STREAM_DESTROYED'\n      }));\n      return true;\n    }\n\n    if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';\n    if (!encoding) encoding = 'utf8'; // convert array buffers and typed array views into buffers\n    // at some point in the future, we may want to do the opposite!\n    // leave strings and buffers as-is\n    // anything else switches us into object mode\n\n    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n      if (isArrayBufferView(chunk)) chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);else if (isArrayBuffer(chunk)) chunk = Buffer.from(chunk);else if (typeof chunk !== 'string') // use the setter so we throw if we have encoding set\n        this.objectMode = true;\n    } // this ensures at this point that the chunk is a buffer or string\n    // don't buffer it up or send it to the decoder\n\n\n    if (!this.objectMode && !chunk.length) {\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable');\n      if (cb) cb();\n      return this.flowing;\n    } // fast-path writing strings of same encoding to a stream with\n    // an empty buffer, skipping the buffer/decoder dance\n\n\n    if (typeof chunk === 'string' && !this[OBJECTMODE] && // unless it is a string already ready for us to use\n    !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {\n      chunk = Buffer.from(chunk, encoding);\n    }\n\n    if (Buffer.isBuffer(chunk) && this[ENCODING]) chunk = this[DECODER].write(chunk);\n\n    if (this.flowing) {\n      // if we somehow have something in the buffer, but we think we're\n      // flowing, then we need to flush all that out first, or we get\n      // chunks coming in out of order.  Can't emit 'drain' here though,\n      // because we're mid-write, so that'd be bad.\n      if (this[BUFFERLENGTH] !== 0) this[FLUSH](true);\n      this.emit('data', chunk);\n    } else this[BUFFERPUSH](chunk);\n\n    if (this[BUFFERLENGTH] !== 0) this.emit('readable');\n    if (cb) cb();\n    return this.flowing;\n  }\n\n  read(n) {\n    if (this[DESTROYED]) return null;\n\n    try {\n      if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) return null;\n      if (this[OBJECTMODE]) n = null;\n\n      if (this.buffer.length > 1 && !this[OBJECTMODE]) {\n        if (this.encoding) this.buffer = new Yallist([Array.from(this.buffer).join('')]);else this.buffer = new Yallist([Buffer.concat(Array.from(this.buffer), this[BUFFERLENGTH])]);\n      }\n\n      return this[READ](n || null, this.buffer.head.value);\n    } finally {\n      this[MAYBE_EMIT_END]();\n    }\n  }\n\n  [READ](n, chunk) {\n    if (n === chunk.length || n === null) this[BUFFERSHIFT]();else {\n      this.buffer.head.value = chunk.slice(n);\n      chunk = chunk.slice(0, n);\n      this[BUFFERLENGTH] -= n;\n    }\n    this.emit('data', chunk);\n    if (!this.buffer.length && !this[EOF]) this.emit('drain');\n    return chunk;\n  }\n\n  end(chunk, encoding, cb) {\n    if (typeof chunk === 'function') cb = chunk, chunk = null;\n    if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';\n    if (chunk) this.write(chunk, encoding);\n    if (cb) this.once('end', cb);\n    this[EOF] = true;\n    this.writable = false; // if we haven't written anything, then go ahead and emit,\n    // even if we're not reading.\n    // we'll re-emit if a new 'end' listener is added anyway.\n    // This makes MP more suitable to write-only use cases.\n\n    if (this.flowing || !this[PAUSED]) this[MAYBE_EMIT_END]();\n    return this;\n  } // don't let the internal resume be overwritten\n\n\n  [RESUME]() {\n    if (this[DESTROYED]) return;\n    this[PAUSED] = false;\n    this[FLOWING] = true;\n    this.emit('resume');\n    if (this.buffer.length) this[FLUSH]();else if (this[EOF]) this[MAYBE_EMIT_END]();else this.emit('drain');\n  }\n\n  resume() {\n    return this[RESUME]();\n  }\n\n  pause() {\n    this[FLOWING] = false;\n    this[PAUSED] = true;\n  }\n\n  get destroyed() {\n    return this[DESTROYED];\n  }\n\n  get flowing() {\n    return this[FLOWING];\n  }\n\n  get paused() {\n    return this[PAUSED];\n  }\n\n  [BUFFERPUSH](chunk) {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1;else this[BUFFERLENGTH] += chunk.length;\n    return this.buffer.push(chunk);\n  }\n\n  [BUFFERSHIFT]() {\n    if (this.buffer.length) {\n      if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1;else this[BUFFERLENGTH] -= this.buffer.head.value.length;\n    }\n\n    return this.buffer.shift();\n  }\n\n  [FLUSH](noDrain) {\n    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));\n\n    if (!noDrain && !this.buffer.length && !this[EOF]) this.emit('drain');\n  }\n\n  [FLUSHCHUNK](chunk) {\n    return chunk ? (this.emit('data', chunk), this.flowing) : false;\n  }\n\n  pipe(dest, opts) {\n    if (this[DESTROYED]) return;\n    const ended = this[EMITTED_END];\n    opts = opts || {};\n    if (dest === process.stdout || dest === process.stderr) opts.end = false;else opts.end = opts.end !== false;\n    const p = {\n      dest: dest,\n      opts: opts,\n      ondrain: _ => this[RESUME]()\n    };\n    this.pipes.push(p);\n    dest.on('drain', p.ondrain);\n    this[RESUME](); // piping an ended stream ends immediately\n\n    if (ended && p.opts.end) p.dest.end();\n    return dest;\n  }\n\n  addListener(ev, fn) {\n    return this.on(ev, fn);\n  }\n\n  on(ev, fn) {\n    try {\n      return super.on(ev, fn);\n    } finally {\n      if (ev === 'data' && !this.pipes.length && !this.flowing) this[RESUME]();else if (isEndish(ev) && this[EMITTED_END]) {\n        super.emit(ev);\n        this.removeAllListeners(ev);\n      }\n    }\n  }\n\n  get emittedEnd() {\n    return this[EMITTED_END];\n  }\n\n  [MAYBE_EMIT_END]() {\n    if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this.buffer.length === 0 && this[EOF]) {\n      this[EMITTING_END] = true;\n      this.emit('end');\n      this.emit('prefinish');\n      this.emit('finish');\n      if (this[CLOSED]) this.emit('close');\n      this[EMITTING_END] = false;\n    }\n  }\n\n  emit(ev, data) {\n    // error and close are only events allowed after calling destroy()\n    if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED]) return;else if (ev === 'data') {\n      if (!data) return;\n      if (this.pipes.length) this.pipes.forEach(p => p.dest.write(data) === false && this.pause());\n    } else if (ev === 'end') {\n      // only actual end gets this treatment\n      if (this[EMITTED_END] === true) return;\n      this[EMITTED_END] = true;\n      this.readable = false;\n\n      if (this[DECODER]) {\n        data = this[DECODER].end();\n\n        if (data) {\n          this.pipes.forEach(p => p.dest.write(data));\n          super.emit('data', data);\n        }\n      }\n\n      this.pipes.forEach(p => {\n        p.dest.removeListener('drain', p.ondrain);\n        if (p.opts.end) p.dest.end();\n      });\n    } else if (ev === 'close') {\n      this[CLOSED] = true; // don't emit close before 'end' and 'finish'\n\n      if (!this[EMITTED_END] && !this[DESTROYED]) return;\n    } // TODO: replace with a spread operator when Node v4 support drops\n\n    const args = new Array(arguments.length);\n    args[0] = ev;\n    args[1] = data;\n\n    if (arguments.length > 2) {\n      for (let i = 2; i < arguments.length; i++) {\n        args[i] = arguments[i];\n      }\n    }\n\n    try {\n      return super.emit.apply(this, args);\n    } finally {\n      if (!isEndish(ev)) this[MAYBE_EMIT_END]();else this.removeAllListeners(ev);\n    }\n  } // const all = await stream.collect()\n\n\n  collect() {\n    const buf = [];\n    if (!this[OBJECTMODE]) buf.dataLength = 0; // set the promise first, in case an error is raised\n    // by triggering the flow here.\n\n    const p = this.promise();\n    this.on('data', c => {\n      buf.push(c);\n      if (!this[OBJECTMODE]) buf.dataLength += c.length;\n    });\n    return p.then(() => buf);\n  } // const data = await stream.concat()\n\n\n  concat() {\n    return this[OBJECTMODE] ? Promise.reject(new Error('cannot concat in objectMode')) : this.collect().then(buf => this[OBJECTMODE] ? Promise.reject(new Error('cannot concat in objectMode')) : this[ENCODING] ? buf.join('') : Buffer.concat(buf, buf.dataLength));\n  } // stream.promise().then(() => done, er => emitted error)\n\n\n  promise() {\n    return new Promise((resolve, reject) => {\n      this.on(DESTROYED, () => reject(new Error('stream destroyed')));\n      this.on('end', () => resolve());\n      this.on('error', er => reject(er));\n    });\n  } // for await (let chunk of stream)\n\n\n  [ASYNCITERATOR]() {\n    const next = () => {\n      const res = this.read();\n      if (res !== null) return Promise.resolve({\n        done: false,\n        value: res\n      });\n      if (this[EOF]) return Promise.resolve({\n        done: true\n      });\n      let resolve = null;\n      let reject = null;\n\n      const onerr = er => {\n        this.removeListener('data', ondata);\n        this.removeListener('end', onend);\n        reject(er);\n      };\n\n      const ondata = value => {\n        this.removeListener('error', onerr);\n        this.removeListener('end', onend);\n        this.pause();\n        resolve({\n          value: value,\n          done: !!this[EOF]\n        });\n      };\n\n      const onend = () => {\n        this.removeListener('error', onerr);\n        this.removeListener('data', ondata);\n        resolve({\n          done: true\n        });\n      };\n\n      const ondestroy = () => onerr(new Error('stream destroyed'));\n\n      return new Promise((res, rej) => {\n        reject = rej;\n        resolve = res;\n        this.once(DESTROYED, ondestroy);\n        this.once('error', onerr);\n        this.once('end', onend);\n        this.once('data', ondata);\n      });\n    };\n\n    return {\n      next\n    };\n  } // for (let chunk of stream)\n\n\n  [ITERATOR]() {\n    const next = () => {\n      const value = this.read();\n      const done = value === null;\n      return {\n        value,\n        done\n      };\n    };\n\n    return {\n      next\n    };\n  }\n\n  destroy(er) {\n    if (this[DESTROYED]) {\n      if (er) this.emit('error', er);else this.emit(DESTROYED);\n      return this;\n    }\n\n    this[DESTROYED] = true; // throw away all buffered data, it's never coming out\n\n    this.buffer = new Yallist();\n    this[BUFFERLENGTH] = 0;\n    if (typeof this.close === 'function' && !this[CLOSED]) this.close();\n    if (er) this.emit('error', er);else // if no error to emit, still reject pending promises\n      this.emit(DESTROYED);\n    return this;\n  }\n\n  static isStream(s) {\n    return !!s && (s instanceof Minipass || s instanceof Stream || s instanceof EE && (typeof s.pipe === 'function' || // readable\n    typeof s.write === 'function' && typeof s.end === 'function' // writable\n    ));\n  }\n\n};","map":{"version":3,"sources":["E:/Important/FIT/project-front-end/FrontEnd_ThayLong_Nhom-21/app-chat/node_modules/minipass/index.js"],"names":["EE","require","Stream","Yallist","SD","StringDecoder","EOF","Symbol","MAYBE_EMIT_END","EMITTED_END","EMITTING_END","CLOSED","READ","FLUSH","FLUSHCHUNK","ENCODING","DECODER","FLOWING","PAUSED","RESUME","BUFFERLENGTH","BUFFERPUSH","BUFFERSHIFT","OBJECTMODE","DESTROYED","doIter","global","_MP_NO_ITERATOR_SYMBOLS_","ASYNCITERATOR","asyncIterator","ITERATOR","iterator","isEndish","ev","isArrayBuffer","b","ArrayBuffer","constructor","name","byteLength","isArrayBufferView","Buffer","isBuffer","isView","module","exports","Minipass","options","pipes","buffer","objectMode","encoding","writable","readable","bufferLength","enc","Error","lastNeed","length","map","chunk","write","setEncoding","om","cb","emit","Object","assign","code","from","byteOffset","flowing","read","n","Array","join","concat","head","value","slice","end","once","resume","pause","destroyed","paused","push","shift","noDrain","pipe","dest","opts","ended","process","stdout","stderr","p","ondrain","_","on","addListener","fn","removeAllListeners","emittedEnd","data","forEach","removeListener","args","arguments","i","apply","collect","buf","dataLength","promise","c","then","Promise","reject","resolve","er","next","res","done","onerr","ondata","onend","ondestroy","rej","destroy","close","isStream","s"],"mappings":"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","sourcesContent":["'use strict'\r\nconst EE = require('events')\r\nconst Stream = require('stream')\r\nconst Yallist = require('yallist')\r\nconst SD = require('string_decoder').StringDecoder\r\n\r\nconst EOF = Symbol('EOF')\r\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd')\r\nconst EMITTED_END = Symbol('emittedEnd')\r\nconst EMITTING_END = Symbol('emittingEnd')\r\nconst CLOSED = Symbol('closed')\r\nconst READ = Symbol('read')\r\nconst FLUSH = Symbol('flush')\r\nconst FLUSHCHUNK = Symbol('flushChunk')\r\nconst ENCODING = Symbol('encoding')\r\nconst DECODER = Symbol('decoder')\r\nconst FLOWING = Symbol('flowing')\r\nconst PAUSED = Symbol('paused')\r\nconst RESUME = Symbol('resume')\r\nconst BUFFERLENGTH = Symbol('bufferLength')\r\nconst BUFFERPUSH = Symbol('bufferPush')\r\nconst BUFFERSHIFT = Symbol('bufferShift')\r\nconst OBJECTMODE = Symbol('objectMode')\r\nconst DESTROYED = Symbol('destroyed')\r\n\r\n// TODO remove when Node v8 support drops\r\nconst doIter = global._MP_NO_ITERATOR_SYMBOLS_  !== '1'\r\nconst ASYNCITERATOR = doIter && Symbol.asyncIterator\r\n  || Symbol('asyncIterator not implemented')\r\nconst ITERATOR = doIter && Symbol.iterator\r\n  || Symbol('iterator not implemented')\r\n\r\n// events that mean 'the stream is over'\r\n// these are treated specially, and re-emitted\r\n// if they are listened for after emitting.\r\nconst isEndish = ev =>\r\n  ev === 'end' ||\r\n  ev === 'finish' ||\r\n  ev === 'prefinish'\r\n\r\nconst isArrayBuffer = b => b instanceof ArrayBuffer ||\r\n  typeof b === 'object' &&\r\n  b.constructor &&\r\n  b.constructor.name === 'ArrayBuffer' &&\r\n  b.byteLength >= 0\r\n\r\nconst isArrayBufferView = b => !Buffer.isBuffer(b) && ArrayBuffer.isView(b)\r\n\r\nmodule.exports = class Minipass extends Stream {\r\n  constructor (options) {\r\n    super()\r\n    this[FLOWING] = false\r\n    // whether we're explicitly paused\r\n    this[PAUSED] = false\r\n    this.pipes = new Yallist()\r\n    this.buffer = new Yallist()\r\n    this[OBJECTMODE] = options && options.objectMode || false\r\n    if (this[OBJECTMODE])\r\n      this[ENCODING] = null\r\n    else\r\n      this[ENCODING] = options && options.encoding || null\r\n    if (this[ENCODING] === 'buffer')\r\n      this[ENCODING] = null\r\n    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null\r\n    this[EOF] = false\r\n    this[EMITTED_END] = false\r\n    this[EMITTING_END] = false\r\n    this[CLOSED] = false\r\n    this.writable = true\r\n    this.readable = true\r\n    this[BUFFERLENGTH] = 0\r\n    this[DESTROYED] = false\r\n  }\r\n\r\n  get bufferLength () { return this[BUFFERLENGTH] }\r\n\r\n  get encoding () { return this[ENCODING] }\r\n  set encoding (enc) {\r\n    if (this[OBJECTMODE])\r\n      throw new Error('cannot set encoding in objectMode')\r\n\r\n    if (this[ENCODING] && enc !== this[ENCODING] &&\r\n        (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))\r\n      throw new Error('cannot change encoding')\r\n\r\n    if (this[ENCODING] !== enc) {\r\n      this[DECODER] = enc ? new SD(enc) : null\r\n      if (this.buffer.length)\r\n        this.buffer = this.buffer.map(chunk => this[DECODER].write(chunk))\r\n    }\r\n\r\n    this[ENCODING] = enc\r\n  }\r\n\r\n  setEncoding (enc) {\r\n    this.encoding = enc\r\n  }\r\n\r\n  get objectMode () { return this[OBJECTMODE] }\r\n  set objectMode (om) { this[OBJECTMODE] = this[OBJECTMODE] || !!om }\r\n\r\n  write (chunk, encoding, cb) {\r\n    if (this[EOF])\r\n      throw new Error('write after end')\r\n\r\n    if (this[DESTROYED]) {\r\n      this.emit('error', Object.assign(\r\n        new Error('Cannot call write after a stream was destroyed'),\r\n        { code: 'ERR_STREAM_DESTROYED' }\r\n      ))\r\n      return true\r\n    }\r\n\r\n    if (typeof encoding === 'function')\r\n      cb = encoding, encoding = 'utf8'\r\n\r\n    if (!encoding)\r\n      encoding = 'utf8'\r\n\r\n    // convert array buffers and typed array views into buffers\r\n    // at some point in the future, we may want to do the opposite!\r\n    // leave strings and buffers as-is\r\n    // anything else switches us into object mode\r\n    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\r\n      if (isArrayBufferView(chunk))\r\n        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength)\r\n      else if (isArrayBuffer(chunk))\r\n        chunk = Buffer.from(chunk)\r\n      else if (typeof chunk !== 'string')\r\n        // use the setter so we throw if we have encoding set\r\n        this.objectMode = true\r\n    }\r\n\r\n    // this ensures at this point that the chunk is a buffer or string\r\n    // don't buffer it up or send it to the decoder\r\n    if (!this.objectMode && !chunk.length) {\r\n      if (this[BUFFERLENGTH] !== 0)\r\n        this.emit('readable')\r\n      if (cb)\r\n        cb()\r\n      return this.flowing\r\n    }\r\n\r\n    // fast-path writing strings of same encoding to a stream with\r\n    // an empty buffer, skipping the buffer/decoder dance\r\n    if (typeof chunk === 'string' && !this[OBJECTMODE] &&\r\n        // unless it is a string already ready for us to use\r\n        !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {\r\n      chunk = Buffer.from(chunk, encoding)\r\n    }\r\n\r\n    if (Buffer.isBuffer(chunk) && this[ENCODING])\r\n      chunk = this[DECODER].write(chunk)\r\n\r\n    if (this.flowing) {\r\n      // if we somehow have something in the buffer, but we think we're\r\n      // flowing, then we need to flush all that out first, or we get\r\n      // chunks coming in out of order.  Can't emit 'drain' here though,\r\n      // because we're mid-write, so that'd be bad.\r\n      if (this[BUFFERLENGTH] !== 0)\r\n        this[FLUSH](true)\r\n      this.emit('data', chunk)\r\n    } else\r\n      this[BUFFERPUSH](chunk)\r\n\r\n    if (this[BUFFERLENGTH] !== 0)\r\n      this.emit('readable')\r\n\r\n    if (cb)\r\n      cb()\r\n\r\n    return this.flowing\r\n  }\r\n\r\n  read (n) {\r\n    if (this[DESTROYED])\r\n      return null\r\n\r\n    try {\r\n      if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH])\r\n        return null\r\n\r\n      if (this[OBJECTMODE])\r\n        n = null\r\n\r\n      if (this.buffer.length > 1 && !this[OBJECTMODE]) {\r\n        if (this.encoding)\r\n          this.buffer = new Yallist([\r\n            Array.from(this.buffer).join('')\r\n          ])\r\n        else\r\n          this.buffer = new Yallist([\r\n            Buffer.concat(Array.from(this.buffer), this[BUFFERLENGTH])\r\n          ])\r\n      }\r\n\r\n      return this[READ](n || null, this.buffer.head.value)\r\n    } finally {\r\n      this[MAYBE_EMIT_END]()\r\n    }\r\n  }\r\n\r\n  [READ] (n, chunk) {\r\n    if (n === chunk.length || n === null)\r\n      this[BUFFERSHIFT]()\r\n    else {\r\n      this.buffer.head.value = chunk.slice(n)\r\n      chunk = chunk.slice(0, n)\r\n      this[BUFFERLENGTH] -= n\r\n    }\r\n\r\n    this.emit('data', chunk)\r\n\r\n    if (!this.buffer.length && !this[EOF])\r\n      this.emit('drain')\r\n\r\n    return chunk\r\n  }\r\n\r\n  end (chunk, encoding, cb) {\r\n    if (typeof chunk === 'function')\r\n      cb = chunk, chunk = null\r\n    if (typeof encoding === 'function')\r\n      cb = encoding, encoding = 'utf8'\r\n    if (chunk)\r\n      this.write(chunk, encoding)\r\n    if (cb)\r\n      this.once('end', cb)\r\n    this[EOF] = true\r\n    this.writable = false\r\n\r\n    // if we haven't written anything, then go ahead and emit,\r\n    // even if we're not reading.\r\n    // we'll re-emit if a new 'end' listener is added anyway.\r\n    // This makes MP more suitable to write-only use cases.\r\n    if (this.flowing || !this[PAUSED])\r\n      this[MAYBE_EMIT_END]()\r\n    return this\r\n  }\r\n\r\n  // don't let the internal resume be overwritten\r\n  [RESUME] () {\r\n    if (this[DESTROYED])\r\n      return\r\n\r\n    this[PAUSED] = false\r\n    this[FLOWING] = true\r\n    this.emit('resume')\r\n    if (this.buffer.length)\r\n      this[FLUSH]()\r\n    else if (this[EOF])\r\n      this[MAYBE_EMIT_END]()\r\n    else\r\n      this.emit('drain')\r\n  }\r\n\r\n  resume () {\r\n    return this[RESUME]()\r\n  }\r\n\r\n  pause () {\r\n    this[FLOWING] = false\r\n    this[PAUSED] = true\r\n  }\r\n\r\n  get destroyed () {\r\n    return this[DESTROYED]\r\n  }\r\n\r\n  get flowing () {\r\n    return this[FLOWING]\r\n  }\r\n\r\n  get paused () {\r\n    return this[PAUSED]\r\n  }\r\n\r\n  [BUFFERPUSH] (chunk) {\r\n    if (this[OBJECTMODE])\r\n      this[BUFFERLENGTH] += 1\r\n    else\r\n      this[BUFFERLENGTH] += chunk.length\r\n    return this.buffer.push(chunk)\r\n  }\r\n\r\n  [BUFFERSHIFT] () {\r\n    if (this.buffer.length) {\r\n      if (this[OBJECTMODE])\r\n        this[BUFFERLENGTH] -= 1\r\n      else\r\n        this[BUFFERLENGTH] -= this.buffer.head.value.length\r\n    }\r\n    return this.buffer.shift()\r\n  }\r\n\r\n  [FLUSH] (noDrain) {\r\n    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()))\r\n\r\n    if (!noDrain && !this.buffer.length && !this[EOF])\r\n      this.emit('drain')\r\n  }\r\n\r\n  [FLUSHCHUNK] (chunk) {\r\n    return chunk ? (this.emit('data', chunk), this.flowing) : false\r\n  }\r\n\r\n  pipe (dest, opts) {\r\n    if (this[DESTROYED])\r\n      return\r\n\r\n    const ended = this[EMITTED_END]\r\n    opts = opts || {}\r\n    if (dest === process.stdout || dest === process.stderr)\r\n      opts.end = false\r\n    else\r\n      opts.end = opts.end !== false\r\n\r\n    const p = { dest: dest, opts: opts, ondrain: _ => this[RESUME]() }\r\n    this.pipes.push(p)\r\n\r\n    dest.on('drain', p.ondrain)\r\n    this[RESUME]()\r\n    // piping an ended stream ends immediately\r\n    if (ended && p.opts.end)\r\n      p.dest.end()\r\n    return dest\r\n  }\r\n\r\n  addListener (ev, fn) {\r\n    return this.on(ev, fn)\r\n  }\r\n\r\n  on (ev, fn) {\r\n    try {\r\n      return super.on(ev, fn)\r\n    } finally {\r\n      if (ev === 'data' && !this.pipes.length && !this.flowing)\r\n        this[RESUME]()\r\n      else if (isEndish(ev) && this[EMITTED_END]) {\r\n        super.emit(ev)\r\n        this.removeAllListeners(ev)\r\n      }\r\n    }\r\n  }\r\n\r\n  get emittedEnd () {\r\n    return this[EMITTED_END]\r\n  }\r\n\r\n  [MAYBE_EMIT_END] () {\r\n    if (!this[EMITTING_END] &&\r\n        !this[EMITTED_END] &&\r\n        !this[DESTROYED] &&\r\n        this.buffer.length === 0 &&\r\n        this[EOF]) {\r\n      this[EMITTING_END] = true\r\n      this.emit('end')\r\n      this.emit('prefinish')\r\n      this.emit('finish')\r\n      if (this[CLOSED])\r\n        this.emit('close')\r\n      this[EMITTING_END] = false\r\n    }\r\n  }\r\n\r\n  emit (ev, data) {\r\n    // error and close are only events allowed after calling destroy()\r\n    if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED])\r\n      return\r\n    else if (ev === 'data') {\r\n      if (!data)\r\n        return\r\n\r\n      if (this.pipes.length)\r\n        this.pipes.forEach(p =>\r\n          p.dest.write(data) === false && this.pause())\r\n    } else if (ev === 'end') {\r\n      // only actual end gets this treatment\r\n      if (this[EMITTED_END] === true)\r\n        return\r\n\r\n      this[EMITTED_END] = true\r\n      this.readable = false\r\n\r\n      if (this[DECODER]) {\r\n        data = this[DECODER].end()\r\n        if (data) {\r\n          this.pipes.forEach(p => p.dest.write(data))\r\n          super.emit('data', data)\r\n        }\r\n      }\r\n\r\n      this.pipes.forEach(p => {\r\n        p.dest.removeListener('drain', p.ondrain)\r\n        if (p.opts.end)\r\n          p.dest.end()\r\n      })\r\n    } else if (ev === 'close') {\r\n      this[CLOSED] = true\r\n      // don't emit close before 'end' and 'finish'\r\n      if (!this[EMITTED_END] && !this[DESTROYED])\r\n        return\r\n    }\r\n\r\n    // TODO: replace with a spread operator when Node v4 support drops\r\n    const args = new Array(arguments.length)\r\n    args[0] = ev\r\n    args[1] = data\r\n    if (arguments.length > 2) {\r\n      for (let i = 2; i < arguments.length; i++) {\r\n        args[i] = arguments[i]\r\n      }\r\n    }\r\n\r\n    try {\r\n      return super.emit.apply(this, args)\r\n    } finally {\r\n      if (!isEndish(ev))\r\n        this[MAYBE_EMIT_END]()\r\n      else\r\n        this.removeAllListeners(ev)\r\n    }\r\n  }\r\n\r\n  // const all = await stream.collect()\r\n  collect () {\r\n    const buf = []\r\n    if (!this[OBJECTMODE])\r\n      buf.dataLength = 0\r\n    // set the promise first, in case an error is raised\r\n    // by triggering the flow here.\r\n    const p = this.promise()\r\n    this.on('data', c => {\r\n      buf.push(c)\r\n      if (!this[OBJECTMODE])\r\n        buf.dataLength += c.length\r\n    })\r\n    return p.then(() => buf)\r\n  }\r\n\r\n  // const data = await stream.concat()\r\n  concat () {\r\n    return this[OBJECTMODE]\r\n      ? Promise.reject(new Error('cannot concat in objectMode'))\r\n      : this.collect().then(buf =>\r\n          this[OBJECTMODE]\r\n            ? Promise.reject(new Error('cannot concat in objectMode'))\r\n            : this[ENCODING] ? buf.join('') : Buffer.concat(buf, buf.dataLength))\r\n  }\r\n\r\n  // stream.promise().then(() => done, er => emitted error)\r\n  promise () {\r\n    return new Promise((resolve, reject) => {\r\n      this.on(DESTROYED, () => reject(new Error('stream destroyed')))\r\n      this.on('end', () => resolve())\r\n      this.on('error', er => reject(er))\r\n    })\r\n  }\r\n\r\n  // for await (let chunk of stream)\r\n  [ASYNCITERATOR] () {\r\n    const next = () => {\r\n      const res = this.read()\r\n      if (res !== null)\r\n        return Promise.resolve({ done: false, value: res })\r\n\r\n      if (this[EOF])\r\n        return Promise.resolve({ done: true })\r\n\r\n      let resolve = null\r\n      let reject = null\r\n      const onerr = er => {\r\n        this.removeListener('data', ondata)\r\n        this.removeListener('end', onend)\r\n        reject(er)\r\n      }\r\n      const ondata = value => {\r\n        this.removeListener('error', onerr)\r\n        this.removeListener('end', onend)\r\n        this.pause()\r\n        resolve({ value: value, done: !!this[EOF] })\r\n      }\r\n      const onend = () => {\r\n        this.removeListener('error', onerr)\r\n        this.removeListener('data', ondata)\r\n        resolve({ done: true })\r\n      }\r\n      const ondestroy = () => onerr(new Error('stream destroyed'))\r\n      return new Promise((res, rej) => {\r\n        reject = rej\r\n        resolve = res\r\n        this.once(DESTROYED, ondestroy)\r\n        this.once('error', onerr)\r\n        this.once('end', onend)\r\n        this.once('data', ondata)\r\n      })\r\n    }\r\n\r\n    return { next }\r\n  }\r\n\r\n  // for (let chunk of stream)\r\n  [ITERATOR] () {\r\n    const next = () => {\r\n      const value = this.read()\r\n      const done = value === null\r\n      return { value, done }\r\n    }\r\n    return { next }\r\n  }\r\n\r\n  destroy (er) {\r\n    if (this[DESTROYED]) {\r\n      if (er)\r\n        this.emit('error', er)\r\n      else\r\n        this.emit(DESTROYED)\r\n      return this\r\n    }\r\n\r\n    this[DESTROYED] = true\r\n\r\n    // throw away all buffered data, it's never coming out\r\n    this.buffer = new Yallist()\r\n    this[BUFFERLENGTH] = 0\r\n\r\n    if (typeof this.close === 'function' && !this[CLOSED])\r\n      this.close()\r\n\r\n    if (er)\r\n      this.emit('error', er)\r\n    else // if no error to emit, still reject pending promises\r\n      this.emit(DESTROYED)\r\n\r\n    return this\r\n  }\r\n\r\n  static isStream (s) {\r\n    return !!s && (s instanceof Minipass || s instanceof Stream ||\r\n      s instanceof EE && (\r\n        typeof s.pipe === 'function' || // readable\r\n        (typeof s.write === 'function' && typeof s.end === 'function') // writable\r\n      ))\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}