{"ast":null,"code":"'use strict';\n\nconst fs = require('graceful-fs');\n\nconst os = require('os');\n\nconst tar = require('tar');\n\nconst path = require('path');\n\nconst crypto = require('crypto');\n\nconst log = require('npmlog');\n\nconst semver = require('semver');\n\nconst request = require('request');\n\nconst processRelease = require('./process-release');\n\nconst win = process.platform === 'win32';\n\nconst getProxyFromURI = require('./proxy');\n\nfunction install(fs, gyp, argv, callback) {\n  var release = processRelease(argv, gyp, process.version, process.release); // ensure no double-callbacks happen\n\n  function cb(err) {\n    if (cb.done) {\n      return;\n    }\n\n    cb.done = true;\n\n    if (err) {\n      log.warn('install', 'got an error, rolling back install'); // roll-back the install if anything went wrong\n\n      gyp.commands.remove([release.versionDir], function () {\n        callback(err);\n      });\n    } else {\n      callback(null, release.version);\n    }\n  } // Determine which node dev files version we are installing\n\n\n  log.verbose('install', 'input version string %j', release.version);\n\n  if (!release.semver) {\n    // could not parse the version string with semver\n    return callback(new Error('Invalid version number: ' + release.version));\n  }\n\n  if (semver.lt(release.version, '0.8.0')) {\n    return callback(new Error('Minimum target version is `0.8.0` or greater. Got: ' + release.version));\n  } // 0.x.y-pre versions are not published yet and cannot be installed. Bail.\n\n\n  if (release.semver.prerelease[0] === 'pre') {\n    log.verbose('detected \"pre\" node version', release.version);\n\n    if (gyp.opts.nodedir) {\n      log.verbose('--nodedir flag was passed; skipping install', gyp.opts.nodedir);\n      callback();\n    } else {\n      callback(new Error('\"pre\" versions of node cannot be installed, use the --nodedir flag instead'));\n    }\n\n    return;\n  } // flatten version into String\n\n\n  log.verbose('install', 'installing version: %s', release.versionDir); // the directory where the dev files will be installed\n\n  var devDir = path.resolve(gyp.devDir, release.versionDir); // If '--ensure' was passed, then don't *always* install the version;\n  // check if it is already installed, and only install when needed\n\n  if (gyp.opts.ensure) {\n    log.verbose('install', '--ensure was passed, so won\\'t reinstall if already installed');\n    fs.stat(devDir, function (err) {\n      if (err) {\n        if (err.code === 'ENOENT') {\n          log.verbose('install', 'version not already installed, continuing with install', release.version);\n          go();\n        } else if (err.code === 'EACCES') {\n          eaccesFallback(err);\n        } else {\n          cb(err);\n        }\n\n        return;\n      }\n\n      log.verbose('install', 'version is already installed, need to check \"installVersion\"');\n      var installVersionFile = path.resolve(devDir, 'installVersion');\n      fs.readFile(installVersionFile, 'ascii', function (err, ver) {\n        if (err && err.code !== 'ENOENT') {\n          return cb(err);\n        }\n\n        var installVersion = parseInt(ver, 10) || 0;\n        log.verbose('got \"installVersion\"', installVersion);\n        log.verbose('needs \"installVersion\"', gyp.package.installVersion);\n\n        if (installVersion < gyp.package.installVersion) {\n          log.verbose('install', 'version is no good; reinstalling');\n          go();\n        } else {\n          log.verbose('install', 'version is good');\n          cb();\n        }\n      });\n    });\n  } else {\n    go();\n  }\n\n  function getContentSha(res, callback) {\n    var shasum = crypto.createHash('sha256');\n    res.on('data', function (chunk) {\n      shasum.update(chunk);\n    }).on('end', function () {\n      callback(null, shasum.digest('hex'));\n    });\n  }\n\n  function go() {\n    log.verbose('ensuring nodedir is created', devDir); // first create the dir for the node dev files\n\n    fs.mkdir(devDir, {\n      recursive: true\n    }, function (err, created) {\n      if (err) {\n        if (err.code === 'EACCES') {\n          eaccesFallback(err);\n        } else {\n          cb(err);\n        }\n\n        return;\n      }\n\n      if (created) {\n        log.verbose('created nodedir', created);\n      } // now download the node tarball\n\n\n      var tarPath = gyp.opts.tarball;\n      var badDownload = false;\n      var extractCount = 0;\n      var contentShasums = {};\n      var expectShasums = {}; // checks if a file to be extracted from the tarball is valid.\n      // only .h header files and the gyp files get extracted\n\n      function isValid(path) {\n        var isValid = valid(path);\n\n        if (isValid) {\n          log.verbose('extracted file from tarball', path);\n          extractCount++;\n        } else {\n          // invalid\n          log.silly('ignoring from tarball', path);\n        }\n\n        return isValid;\n      } // download the tarball and extract!\n\n\n      if (tarPath) {\n        return tar.extract({\n          file: tarPath,\n          strip: 1,\n          filter: isValid,\n          cwd: devDir\n        }).then(afterTarball, cb);\n      }\n\n      try {\n        var req = download(gyp, process.env, release.tarballUrl);\n      } catch (e) {\n        return cb(e);\n      } // something went wrong downloading the tarball?\n\n\n      req.on('error', function (err) {\n        if (err.code === 'ENOTFOUND') {\n          return cb(new Error('This is most likely not a problem with node-gyp or the package itself and\\n' + 'is related to network connectivity. In most cases you are behind a proxy or have bad \\n' + 'network settings.'));\n        }\n\n        badDownload = true;\n        cb(err);\n      });\n      req.on('close', function () {\n        if (extractCount === 0) {\n          cb(new Error('Connection closed while downloading tarball file'));\n        }\n      });\n      req.on('response', function (res) {\n        if (res.statusCode !== 200) {\n          badDownload = true;\n          cb(new Error(res.statusCode + ' response downloading ' + release.tarballUrl));\n          return;\n        } // content checksum\n\n\n        getContentSha(res, function (_, checksum) {\n          var filename = path.basename(release.tarballUrl).trim();\n          contentShasums[filename] = checksum;\n          log.verbose('content checksum', filename, checksum);\n        }); // start unzipping and untaring\n\n        res.pipe(tar.extract({\n          strip: 1,\n          cwd: devDir,\n          filter: isValid\n        }).on('close', afterTarball).on('error', cb));\n      }); // invoked after the tarball has finished being extracted\n\n      function afterTarball() {\n        if (badDownload) {\n          return;\n        }\n\n        if (extractCount === 0) {\n          return cb(new Error('There was a fatal problem while downloading/extracting the tarball'));\n        }\n\n        log.verbose('tarball', 'done parsing tarball');\n        var async = 0;\n\n        if (win) {\n          // need to download node.lib\n          async++;\n          downloadNodeLib(deref);\n        } // write the \"installVersion\" file\n\n\n        async++;\n        var installVersionPath = path.resolve(devDir, 'installVersion');\n        fs.writeFile(installVersionPath, gyp.package.installVersion + '\\n', deref); // Only download SHASUMS.txt if we downloaded something in need of SHA verification\n\n        if (!tarPath || win) {\n          // download SHASUMS.txt\n          async++;\n          downloadShasums(deref);\n        }\n\n        if (async === 0) {\n          // no async tasks required\n          cb();\n        }\n\n        function deref(err) {\n          if (err) {\n            return cb(err);\n          }\n\n          async--;\n\n          if (!async) {\n            log.verbose('download contents checksum', JSON.stringify(contentShasums)); // check content shasums\n\n            for (var k in contentShasums) {\n              log.verbose('validating download checksum for ' + k, '(%s == %s)', contentShasums[k], expectShasums[k]);\n\n              if (contentShasums[k] !== expectShasums[k]) {\n                cb(new Error(k + ' local checksum ' + contentShasums[k] + ' not match remote ' + expectShasums[k]));\n                return;\n              }\n            }\n\n            cb();\n          }\n        }\n      }\n\n      function downloadShasums(done) {\n        log.verbose('check download content checksum, need to download `SHASUMS256.txt`...');\n        log.verbose('checksum url', release.shasumsUrl);\n\n        try {\n          var req = download(gyp, process.env, release.shasumsUrl);\n        } catch (e) {\n          return cb(e);\n        }\n\n        req.on('error', done);\n        req.on('response', function (res) {\n          if (res.statusCode !== 200) {\n            done(new Error(res.statusCode + ' status code downloading checksum'));\n            return;\n          }\n\n          var chunks = [];\n          res.on('data', function (chunk) {\n            chunks.push(chunk);\n          });\n          res.on('end', function () {\n            var lines = Buffer.concat(chunks).toString().trim().split('\\n');\n            lines.forEach(function (line) {\n              var items = line.trim().split(/\\s+/);\n\n              if (items.length !== 2) {\n                return;\n              } // 0035d18e2dcf9aad669b1c7c07319e17abfe3762  ./node-v0.11.4.tar.gz\n\n\n              var name = items[1].replace(/^\\.\\//, '');\n              expectShasums[name] = items[0];\n            });\n            log.verbose('checksum data', JSON.stringify(expectShasums));\n            done();\n          });\n        });\n      }\n\n      function downloadNodeLib(done) {\n        log.verbose('on Windows; need to download `' + release.name + '.lib`...');\n        var archs = ['ia32', 'x64', 'arm64'];\n        var async = archs.length;\n        archs.forEach(function (arch) {\n          var dir = path.resolve(devDir, arch);\n          var targetLibPath = path.resolve(dir, release.name + '.lib');\n          var libUrl = release[arch].libUrl;\n          var libPath = release[arch].libPath;\n          var name = arch + ' ' + release.name + '.lib';\n          log.verbose(name, 'dir', dir);\n          log.verbose(name, 'url', libUrl);\n          fs.mkdir(dir, {\n            recursive: true\n          }, function (err) {\n            if (err) {\n              return done(err);\n            }\n\n            log.verbose('streaming', name, 'to:', targetLibPath);\n\n            try {\n              var req = download(gyp, process.env, libUrl, cb);\n            } catch (e) {\n              return cb(e);\n            }\n\n            req.on('error', done);\n            req.on('response', function (res) {\n              if (res.statusCode === 403 || res.statusCode === 404) {\n                if (arch === 'arm64') {\n                  // Arm64 is a newer platform on Windows and not all node distributions provide it.\n                  log.verbose(`${name} was not found in ${libUrl}`);\n                } else {\n                  log.warn(`${name} was not found in ${libUrl}`);\n                }\n\n                return;\n              } else if (res.statusCode !== 200) {\n                done(new Error(res.statusCode + ' status code downloading ' + name));\n                return;\n              }\n\n              getContentSha(res, function (_, checksum) {\n                contentShasums[libPath] = checksum;\n                log.verbose('content checksum', libPath, checksum);\n              });\n              var ws = fs.createWriteStream(targetLibPath);\n              ws.on('error', cb);\n              req.pipe(ws);\n            });\n            req.on('end', function () {\n              --async || done();\n            });\n          });\n        });\n      } // downloadNodeLib()\n\n    }); // mkdir()\n  } // go()\n\n  /**\r\n   * Checks if a given filename is \"valid\" for this installation.\r\n   */\n\n\n  function valid(file) {\n    // header files\n    var extname = path.extname(file);\n    return extname === '.h' || extname === '.gypi';\n  }\n  /**\r\n   * The EACCES fallback is a workaround for npm's `sudo` behavior, where\r\n   * it drops the permissions before invoking any child processes (like\r\n   * node-gyp). So what happens is the \"nobody\" user doesn't have\r\n   * permission to create the dev dir. As a fallback, make the tmpdir() be\r\n   * the dev dir for this installation. This is not ideal, but at least\r\n   * the compilation will succeed...\r\n   */\n\n\n  function eaccesFallback(err) {\n    var noretry = '--node_gyp_internal_noretry';\n\n    if (argv.indexOf(noretry) !== -1) {\n      return cb(err);\n    }\n\n    var tmpdir = os.tmpdir();\n    gyp.devDir = path.resolve(tmpdir, '.node-gyp');\n    var userString = '';\n\n    try {\n      // os.userInfo can fail on some systems, it's not critical here\n      userString = ` (\"${os.userInfo().username}\")`;\n    } catch (e) {}\n\n    log.warn('EACCES', 'current user%s does not have permission to access the dev dir \"%s\"', userString, devDir);\n    log.warn('EACCES', 'attempting to reinstall using temporary dev dir \"%s\"', gyp.devDir);\n\n    if (process.cwd() === tmpdir) {\n      log.verbose('tmpdir == cwd', 'automatically will remove dev files after to save disk space');\n      gyp.todo.push({\n        name: 'remove',\n        args: argv\n      });\n    }\n\n    gyp.commands.install([noretry].concat(argv), cb);\n  }\n}\n\nfunction download(gyp, env, url) {\n  log.http('GET', url);\n  var requestOpts = {\n    uri: url,\n    headers: {\n      'User-Agent': 'node-gyp v' + gyp.version + ' (node ' + process.version + ')',\n      Connection: 'keep-alive'\n    }\n  };\n  var cafile = gyp.opts.cafile;\n\n  if (cafile) {\n    requestOpts.ca = readCAFile(cafile);\n  } // basic support for a proxy server\n\n\n  var proxyUrl = getProxyFromURI(gyp, env, url);\n\n  if (proxyUrl) {\n    if (/^https?:\\/\\//i.test(proxyUrl)) {\n      log.verbose('download', 'using proxy url: \"%s\"', proxyUrl);\n      requestOpts.proxy = proxyUrl;\n    } else {\n      log.warn('download', 'ignoring invalid \"proxy\" config setting: \"%s\"', proxyUrl);\n    }\n  }\n\n  var req = request(requestOpts);\n  req.on('response', function (res) {\n    log.http(res.statusCode, url);\n  });\n  return req;\n}\n\nfunction readCAFile(filename) {\n  // The CA file can contain multiple certificates so split on certificate\n  // boundaries.  [\\S\\s]*? is used to match everything including newlines.\n  var ca = fs.readFileSync(filename, 'utf8');\n  var re = /(-----BEGIN CERTIFICATE-----[\\S\\s]*?-----END CERTIFICATE-----)/g;\n  return ca.match(re);\n}\n\nmodule.exports = function (gyp, argv, callback) {\n  return install(fs, gyp, argv, callback);\n};\n\nmodule.exports.test = {\n  download: download,\n  install: install,\n  readCAFile: readCAFile\n};\nmodule.exports.usage = 'Install node development files for the specified node version.';","map":{"version":3,"sources":["E:/Important/FIT/project-front-end/FrontEnd_ThayLong_Nhom-21/app-chat/node_modules/node-gyp/lib/install.js"],"names":["fs","require","os","tar","path","crypto","log","semver","request","processRelease","win","process","platform","getProxyFromURI","install","gyp","argv","callback","release","version","cb","err","done","warn","commands","remove","versionDir","verbose","Error","lt","prerelease","opts","nodedir","devDir","resolve","ensure","stat","code","go","eaccesFallback","installVersionFile","readFile","ver","installVersion","parseInt","package","getContentSha","res","shasum","createHash","on","chunk","update","digest","mkdir","recursive","created","tarPath","tarball","badDownload","extractCount","contentShasums","expectShasums","isValid","valid","silly","extract","file","strip","filter","cwd","then","afterTarball","req","download","env","tarballUrl","e","statusCode","_","checksum","filename","basename","trim","pipe","async","downloadNodeLib","deref","installVersionPath","writeFile","downloadShasums","JSON","stringify","k","shasumsUrl","chunks","push","lines","Buffer","concat","toString","split","forEach","line","items","length","name","replace","archs","arch","dir","targetLibPath","libUrl","libPath","ws","createWriteStream","extname","noretry","indexOf","tmpdir","userString","userInfo","username","todo","args","url","http","requestOpts","uri","headers","Connection","cafile","ca","readCAFile","proxyUrl","test","proxy","readFileSync","re","match","module","exports","usage"],"mappings":"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","sourcesContent":["'use strict'\r\n\r\nconst fs = require('graceful-fs')\r\nconst os = require('os')\r\nconst tar = require('tar')\r\nconst path = require('path')\r\nconst crypto = require('crypto')\r\nconst log = require('npmlog')\r\nconst semver = require('semver')\r\nconst request = require('request')\r\nconst processRelease = require('./process-release')\r\nconst win = process.platform === 'win32'\r\nconst getProxyFromURI = require('./proxy')\r\n\r\nfunction install (fs, gyp, argv, callback) {\r\n  var release = processRelease(argv, gyp, process.version, process.release)\r\n\r\n  // ensure no double-callbacks happen\r\n  function cb (err) {\r\n    if (cb.done) {\r\n      return\r\n    }\r\n    cb.done = true\r\n    if (err) {\r\n      log.warn('install', 'got an error, rolling back install')\r\n      // roll-back the install if anything went wrong\r\n      gyp.commands.remove([release.versionDir], function () {\r\n        callback(err)\r\n      })\r\n    } else {\r\n      callback(null, release.version)\r\n    }\r\n  }\r\n\r\n  // Determine which node dev files version we are installing\r\n  log.verbose('install', 'input version string %j', release.version)\r\n\r\n  if (!release.semver) {\r\n    // could not parse the version string with semver\r\n    return callback(new Error('Invalid version number: ' + release.version))\r\n  }\r\n\r\n  if (semver.lt(release.version, '0.8.0')) {\r\n    return callback(new Error('Minimum target version is `0.8.0` or greater. Got: ' + release.version))\r\n  }\r\n\r\n  // 0.x.y-pre versions are not published yet and cannot be installed. Bail.\r\n  if (release.semver.prerelease[0] === 'pre') {\r\n    log.verbose('detected \"pre\" node version', release.version)\r\n    if (gyp.opts.nodedir) {\r\n      log.verbose('--nodedir flag was passed; skipping install', gyp.opts.nodedir)\r\n      callback()\r\n    } else {\r\n      callback(new Error('\"pre\" versions of node cannot be installed, use the --nodedir flag instead'))\r\n    }\r\n    return\r\n  }\r\n\r\n  // flatten version into String\r\n  log.verbose('install', 'installing version: %s', release.versionDir)\r\n\r\n  // the directory where the dev files will be installed\r\n  var devDir = path.resolve(gyp.devDir, release.versionDir)\r\n\r\n  // If '--ensure' was passed, then don't *always* install the version;\r\n  // check if it is already installed, and only install when needed\r\n  if (gyp.opts.ensure) {\r\n    log.verbose('install', '--ensure was passed, so won\\'t reinstall if already installed')\r\n    fs.stat(devDir, function (err) {\r\n      if (err) {\r\n        if (err.code === 'ENOENT') {\r\n          log.verbose('install', 'version not already installed, continuing with install', release.version)\r\n          go()\r\n        } else if (err.code === 'EACCES') {\r\n          eaccesFallback(err)\r\n        } else {\r\n          cb(err)\r\n        }\r\n        return\r\n      }\r\n      log.verbose('install', 'version is already installed, need to check \"installVersion\"')\r\n      var installVersionFile = path.resolve(devDir, 'installVersion')\r\n      fs.readFile(installVersionFile, 'ascii', function (err, ver) {\r\n        if (err && err.code !== 'ENOENT') {\r\n          return cb(err)\r\n        }\r\n        var installVersion = parseInt(ver, 10) || 0\r\n        log.verbose('got \"installVersion\"', installVersion)\r\n        log.verbose('needs \"installVersion\"', gyp.package.installVersion)\r\n        if (installVersion < gyp.package.installVersion) {\r\n          log.verbose('install', 'version is no good; reinstalling')\r\n          go()\r\n        } else {\r\n          log.verbose('install', 'version is good')\r\n          cb()\r\n        }\r\n      })\r\n    })\r\n  } else {\r\n    go()\r\n  }\r\n\r\n  function getContentSha (res, callback) {\r\n    var shasum = crypto.createHash('sha256')\r\n    res.on('data', function (chunk) {\r\n      shasum.update(chunk)\r\n    }).on('end', function () {\r\n      callback(null, shasum.digest('hex'))\r\n    })\r\n  }\r\n\r\n  function go () {\r\n    log.verbose('ensuring nodedir is created', devDir)\r\n\r\n    // first create the dir for the node dev files\r\n    fs.mkdir(devDir, { recursive: true }, function (err, created) {\r\n      if (err) {\r\n        if (err.code === 'EACCES') {\r\n          eaccesFallback(err)\r\n        } else {\r\n          cb(err)\r\n        }\r\n        return\r\n      }\r\n\r\n      if (created) {\r\n        log.verbose('created nodedir', created)\r\n      }\r\n\r\n      // now download the node tarball\r\n      var tarPath = gyp.opts.tarball\r\n      var badDownload = false\r\n      var extractCount = 0\r\n      var contentShasums = {}\r\n      var expectShasums = {}\r\n\r\n      // checks if a file to be extracted from the tarball is valid.\r\n      // only .h header files and the gyp files get extracted\r\n      function isValid (path) {\r\n        var isValid = valid(path)\r\n        if (isValid) {\r\n          log.verbose('extracted file from tarball', path)\r\n          extractCount++\r\n        } else {\r\n          // invalid\r\n          log.silly('ignoring from tarball', path)\r\n        }\r\n        return isValid\r\n      }\r\n\r\n      // download the tarball and extract!\r\n      if (tarPath) {\r\n        return tar.extract({\r\n          file: tarPath,\r\n          strip: 1,\r\n          filter: isValid,\r\n          cwd: devDir\r\n        }).then(afterTarball, cb)\r\n      }\r\n\r\n      try {\r\n        var req = download(gyp, process.env, release.tarballUrl)\r\n      } catch (e) {\r\n        return cb(e)\r\n      }\r\n\r\n      // something went wrong downloading the tarball?\r\n      req.on('error', function (err) {\r\n        if (err.code === 'ENOTFOUND') {\r\n          return cb(new Error('This is most likely not a problem with node-gyp or the package itself and\\n' +\r\n            'is related to network connectivity. In most cases you are behind a proxy or have bad \\n' +\r\n            'network settings.'))\r\n        }\r\n        badDownload = true\r\n        cb(err)\r\n      })\r\n\r\n      req.on('close', function () {\r\n        if (extractCount === 0) {\r\n          cb(new Error('Connection closed while downloading tarball file'))\r\n        }\r\n      })\r\n\r\n      req.on('response', function (res) {\r\n        if (res.statusCode !== 200) {\r\n          badDownload = true\r\n          cb(new Error(res.statusCode + ' response downloading ' + release.tarballUrl))\r\n          return\r\n        }\r\n        // content checksum\r\n        getContentSha(res, function (_, checksum) {\r\n          var filename = path.basename(release.tarballUrl).trim()\r\n          contentShasums[filename] = checksum\r\n          log.verbose('content checksum', filename, checksum)\r\n        })\r\n\r\n        // start unzipping and untaring\r\n        res.pipe(tar.extract({\r\n          strip: 1,\r\n          cwd: devDir,\r\n          filter: isValid\r\n        }).on('close', afterTarball).on('error', cb))\r\n      })\r\n\r\n      // invoked after the tarball has finished being extracted\r\n      function afterTarball () {\r\n        if (badDownload) {\r\n          return\r\n        }\r\n        if (extractCount === 0) {\r\n          return cb(new Error('There was a fatal problem while downloading/extracting the tarball'))\r\n        }\r\n        log.verbose('tarball', 'done parsing tarball')\r\n        var async = 0\r\n\r\n        if (win) {\r\n          // need to download node.lib\r\n          async++\r\n          downloadNodeLib(deref)\r\n        }\r\n\r\n        // write the \"installVersion\" file\r\n        async++\r\n        var installVersionPath = path.resolve(devDir, 'installVersion')\r\n        fs.writeFile(installVersionPath, gyp.package.installVersion + '\\n', deref)\r\n\r\n        // Only download SHASUMS.txt if we downloaded something in need of SHA verification\r\n        if (!tarPath || win) {\r\n          // download SHASUMS.txt\r\n          async++\r\n          downloadShasums(deref)\r\n        }\r\n\r\n        if (async === 0) {\r\n          // no async tasks required\r\n          cb()\r\n        }\r\n\r\n        function deref (err) {\r\n          if (err) {\r\n            return cb(err)\r\n          }\r\n\r\n          async--\r\n          if (!async) {\r\n            log.verbose('download contents checksum', JSON.stringify(contentShasums))\r\n            // check content shasums\r\n            for (var k in contentShasums) {\r\n              log.verbose('validating download checksum for ' + k, '(%s == %s)', contentShasums[k], expectShasums[k])\r\n              if (contentShasums[k] !== expectShasums[k]) {\r\n                cb(new Error(k + ' local checksum ' + contentShasums[k] + ' not match remote ' + expectShasums[k]))\r\n                return\r\n              }\r\n            }\r\n            cb()\r\n          }\r\n        }\r\n      }\r\n\r\n      function downloadShasums (done) {\r\n        log.verbose('check download content checksum, need to download `SHASUMS256.txt`...')\r\n        log.verbose('checksum url', release.shasumsUrl)\r\n        try {\r\n          var req = download(gyp, process.env, release.shasumsUrl)\r\n        } catch (e) {\r\n          return cb(e)\r\n        }\r\n\r\n        req.on('error', done)\r\n        req.on('response', function (res) {\r\n          if (res.statusCode !== 200) {\r\n            done(new Error(res.statusCode + ' status code downloading checksum'))\r\n            return\r\n          }\r\n\r\n          var chunks = []\r\n          res.on('data', function (chunk) {\r\n            chunks.push(chunk)\r\n          })\r\n          res.on('end', function () {\r\n            var lines = Buffer.concat(chunks).toString().trim().split('\\n')\r\n            lines.forEach(function (line) {\r\n              var items = line.trim().split(/\\s+/)\r\n              if (items.length !== 2) {\r\n                return\r\n              }\r\n\r\n              // 0035d18e2dcf9aad669b1c7c07319e17abfe3762  ./node-v0.11.4.tar.gz\r\n              var name = items[1].replace(/^\\.\\//, '')\r\n              expectShasums[name] = items[0]\r\n            })\r\n\r\n            log.verbose('checksum data', JSON.stringify(expectShasums))\r\n            done()\r\n          })\r\n        })\r\n      }\r\n\r\n      function downloadNodeLib (done) {\r\n        log.verbose('on Windows; need to download `' + release.name + '.lib`...')\r\n        var archs = ['ia32', 'x64', 'arm64']\r\n        var async = archs.length\r\n        archs.forEach(function (arch) {\r\n          var dir = path.resolve(devDir, arch)\r\n          var targetLibPath = path.resolve(dir, release.name + '.lib')\r\n          var libUrl = release[arch].libUrl\r\n          var libPath = release[arch].libPath\r\n          var name = arch + ' ' + release.name + '.lib'\r\n          log.verbose(name, 'dir', dir)\r\n          log.verbose(name, 'url', libUrl)\r\n\r\n          fs.mkdir(dir, { recursive: true }, function (err) {\r\n            if (err) {\r\n              return done(err)\r\n            }\r\n            log.verbose('streaming', name, 'to:', targetLibPath)\r\n\r\n            try {\r\n              var req = download(gyp, process.env, libUrl, cb)\r\n            } catch (e) {\r\n              return cb(e)\r\n            }\r\n\r\n            req.on('error', done)\r\n            req.on('response', function (res) {\r\n              if (res.statusCode === 403 || res.statusCode === 404) {\r\n                if (arch === 'arm64') {\r\n                  // Arm64 is a newer platform on Windows and not all node distributions provide it.\r\n                  log.verbose(`${name} was not found in ${libUrl}`)\r\n                } else {\r\n                  log.warn(`${name} was not found in ${libUrl}`)\r\n                }\r\n                return\r\n              } else if (res.statusCode !== 200) {\r\n                done(new Error(res.statusCode + ' status code downloading ' + name))\r\n                return\r\n              }\r\n\r\n              getContentSha(res, function (_, checksum) {\r\n                contentShasums[libPath] = checksum\r\n                log.verbose('content checksum', libPath, checksum)\r\n              })\r\n\r\n              var ws = fs.createWriteStream(targetLibPath)\r\n              ws.on('error', cb)\r\n              req.pipe(ws)\r\n            })\r\n            req.on('end', function () { --async || done() })\r\n          })\r\n        })\r\n      } // downloadNodeLib()\r\n    }) // mkdir()\r\n  } // go()\r\n\r\n  /**\r\n   * Checks if a given filename is \"valid\" for this installation.\r\n   */\r\n\r\n  function valid (file) {\r\n    // header files\r\n    var extname = path.extname(file)\r\n    return extname === '.h' || extname === '.gypi'\r\n  }\r\n\r\n  /**\r\n   * The EACCES fallback is a workaround for npm's `sudo` behavior, where\r\n   * it drops the permissions before invoking any child processes (like\r\n   * node-gyp). So what happens is the \"nobody\" user doesn't have\r\n   * permission to create the dev dir. As a fallback, make the tmpdir() be\r\n   * the dev dir for this installation. This is not ideal, but at least\r\n   * the compilation will succeed...\r\n   */\r\n\r\n  function eaccesFallback (err) {\r\n    var noretry = '--node_gyp_internal_noretry'\r\n    if (argv.indexOf(noretry) !== -1) {\r\n      return cb(err)\r\n    }\r\n    var tmpdir = os.tmpdir()\r\n    gyp.devDir = path.resolve(tmpdir, '.node-gyp')\r\n    var userString = ''\r\n    try {\r\n      // os.userInfo can fail on some systems, it's not critical here\r\n      userString = ` (\"${os.userInfo().username}\")`\r\n    } catch (e) {}\r\n    log.warn('EACCES', 'current user%s does not have permission to access the dev dir \"%s\"', userString, devDir)\r\n    log.warn('EACCES', 'attempting to reinstall using temporary dev dir \"%s\"', gyp.devDir)\r\n    if (process.cwd() === tmpdir) {\r\n      log.verbose('tmpdir == cwd', 'automatically will remove dev files after to save disk space')\r\n      gyp.todo.push({ name: 'remove', args: argv })\r\n    }\r\n    gyp.commands.install([noretry].concat(argv), cb)\r\n  }\r\n}\r\n\r\nfunction download (gyp, env, url) {\r\n  log.http('GET', url)\r\n\r\n  var requestOpts = {\r\n    uri: url,\r\n    headers: {\r\n      'User-Agent': 'node-gyp v' + gyp.version + ' (node ' + process.version + ')',\r\n      Connection: 'keep-alive'\r\n    }\r\n  }\r\n\r\n  var cafile = gyp.opts.cafile\r\n  if (cafile) {\r\n    requestOpts.ca = readCAFile(cafile)\r\n  }\r\n\r\n  // basic support for a proxy server\r\n  var proxyUrl = getProxyFromURI(gyp, env, url)\r\n  if (proxyUrl) {\r\n    if (/^https?:\\/\\//i.test(proxyUrl)) {\r\n      log.verbose('download', 'using proxy url: \"%s\"', proxyUrl)\r\n      requestOpts.proxy = proxyUrl\r\n    } else {\r\n      log.warn('download', 'ignoring invalid \"proxy\" config setting: \"%s\"', proxyUrl)\r\n    }\r\n  }\r\n\r\n  var req = request(requestOpts)\r\n  req.on('response', function (res) {\r\n    log.http(res.statusCode, url)\r\n  })\r\n\r\n  return req\r\n}\r\n\r\nfunction readCAFile (filename) {\r\n  // The CA file can contain multiple certificates so split on certificate\r\n  // boundaries.  [\\S\\s]*? is used to match everything including newlines.\r\n  var ca = fs.readFileSync(filename, 'utf8')\r\n  var re = /(-----BEGIN CERTIFICATE-----[\\S\\s]*?-----END CERTIFICATE-----)/g\r\n  return ca.match(re)\r\n}\r\n\r\nmodule.exports = function (gyp, argv, callback) {\r\n  return install(fs, gyp, argv, callback)\r\n}\r\nmodule.exports.test = {\r\n  download: download,\r\n  install: install,\r\n  readCAFile: readCAFile\r\n}\r\nmodule.exports.usage = 'Install node development files for the specified node version.'\r\n"]},"metadata":{},"sourceType":"script"}