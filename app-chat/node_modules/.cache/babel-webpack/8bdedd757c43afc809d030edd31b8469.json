{"ast":null,"code":"import _asyncToGenerator from \"E:/Important/FIT/project-front-end/FrontEnd_ThayLong_Nhom-21/app-chat/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { encode, instantiate } from 'media-encoder-host';\nimport { MultiBufferDataView } from 'multi-buffer-data-view';\nimport { on } from 'subscribable-things';\nexport const createWebmPcmMediaRecorderFactory = (createBlobEvent, createInvalidModificationError, createNotSupportedError, decodeWebMChunk) => {\n  return (eventTarget, nativeMediaRecorderConstructor, mediaStream, mimeType) => {\n    const nativeMediaRecorder = new nativeMediaRecorderConstructor(mediaStream, {\n      mimeType: 'audio/webm;codecs=pcm'\n    });\n    const audioTracks = mediaStream.getAudioTracks();\n    const channelCount = audioTracks.length === 0 ? undefined : audioTracks[0].getSettings().channelCount;\n    const sampleRate = audioTracks.length === 0 ? undefined : audioTracks[0].getSettings().sampleRate;\n    let promisedPartialRecording = null;\n\n    const dispatchDataAvailableEvent = arrayBuffers => {\n      eventTarget.dispatchEvent(createBlobEvent('dataavailable', {\n        data: new Blob(arrayBuffers, {\n          type: mimeType\n        })\n      }));\n    };\n\n    const requestNextPartialRecording = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (encoderId, timeslice) {\n        dispatchDataAvailableEvent(yield encode(encoderId, timeslice));\n\n        if (nativeMediaRecorder.state !== 'inactive') {\n          promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n        }\n      });\n\n      return function requestNextPartialRecording(_x, _x2) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n\n    const stop = () => {\n      if (nativeMediaRecorder.state === 'inactive') {\n        return;\n      }\n\n      if (promisedPartialRecording !== null) {\n        promisedPartialRecording.catch(() => {\n          /* @todo Only catch the errors caused by a duplicate call to encode. */\n        });\n        promisedPartialRecording = null;\n      }\n\n      nativeMediaRecorder.stop();\n    };\n\n    nativeMediaRecorder.addEventListener('error', () => {\n      stop(); // Bug #3 & 4: Chrome throws an error event without any error.\n\n      eventTarget.dispatchEvent(new ErrorEvent('error', {\n        error: createInvalidModificationError()\n      }));\n    });\n    return {\n      get mimeType() {\n        return mimeType;\n      },\n\n      get state() {\n        return nativeMediaRecorder.state;\n      },\n\n      start(timeslice) {\n        /*\r\n         * Bug #6: Chrome will emit a blob without any data when asked to encode a MediaStream with a video track into an audio\r\n         * codec.\r\n         */\n        if (mediaStream.getVideoTracks().length > 0) {\n          throw createNotSupportedError();\n        }\n\n        if (nativeMediaRecorder.state === 'inactive') {\n          let promisedDataViewElementTypeEncoderIdAndPort = null;\n\n          if (sampleRate !== undefined) {\n            promisedDataViewElementTypeEncoderIdAndPort = instantiate(mimeType, sampleRate);\n          } // Bug #9: Chrome sometimes fires more than one dataavailable event while being inactive.\n\n\n          let pendingInvocations = 0;\n          const removeEventListener = on(nativeMediaRecorder, 'dataavailable')(({\n            data\n          }) => {\n            pendingInvocations += 1;\n\n            if (promisedDataViewElementTypeEncoderIdAndPort !== null) {\n              promisedDataViewElementTypeEncoderIdAndPort = promisedDataViewElementTypeEncoderIdAndPort.then( /*#__PURE__*/function () {\n                var _ref2 = _asyncToGenerator(function* ({\n                  dataView = null,\n                  elementType = null,\n                  encoderId,\n                  port\n                }) {\n                  const multiOrSingleBufferDataView = dataView === null ? new DataView(yield data.arrayBuffer()) : new MultiBufferDataView([...dataView.buffers, yield data.arrayBuffer()], dataView.byteOffset);\n                  const {\n                    currentElementType,\n                    offset,\n                    contents\n                  } = decodeWebMChunk(multiOrSingleBufferDataView, elementType, channelCount);\n                  const buffers = 'buffer' in multiOrSingleBufferDataView ? [multiOrSingleBufferDataView.buffer] : multiOrSingleBufferDataView.buffers;\n                  const remainingDataView = offset < multiOrSingleBufferDataView.byteLength ? new MultiBufferDataView(buffers, multiOrSingleBufferDataView.byteOffset + offset) : null;\n                  contents.forEach(content => port.postMessage(content, content.map(({\n                    buffer\n                  }) => buffer)));\n                  pendingInvocations -= 1;\n\n                  if (pendingInvocations === 0 && nativeMediaRecorder.state === 'inactive') {\n                    encode(encoderId, null).then(arrayBuffers => {\n                      dispatchDataAvailableEvent(arrayBuffers);\n                      eventTarget.dispatchEvent(new Event('stop'));\n                    });\n                    port.postMessage([]);\n                    port.close();\n                    removeEventListener();\n                  }\n\n                  return {\n                    dataView: remainingDataView,\n                    elementType: currentElementType,\n                    encoderId,\n                    port\n                  };\n                });\n\n                return function (_x3) {\n                  return _ref2.apply(this, arguments);\n                };\n              }());\n            }\n          });\n\n          if (promisedDataViewElementTypeEncoderIdAndPort !== null && timeslice !== undefined) {\n            promisedDataViewElementTypeEncoderIdAndPort.then(({\n              encoderId\n            }) => promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice));\n          }\n        }\n\n        nativeMediaRecorder.start(100);\n      },\n\n      stop\n    };\n  };\n}; //# sourceMappingURL=webm-pcm-media-recorder.js.map","map":null,"metadata":{},"sourceType":"module"}