{"ast":null,"code":"// A path exclusive reservation system\n// reserve([list, of, paths], fn)\n// When the fn is first in line for all its paths, it\n// is called with a cb that clears the reservation.\n//\n// Used by async unpack to avoid clobbering paths in use,\n// while still allowing maximal safe parallelization.\nconst assert = require('assert');\n\nmodule.exports = () => {\n  // path => [function or Set]\n  // A Set object means a directory reservation\n  // A fn is a direct reservation on that path\n  const queues = new Map(); // fn => {paths:[path,...], dirs:[path, ...]}\n\n  const reservations = new Map(); // return a set of parent dirs for a given path\n\n  const {\n    join\n  } = require('path');\n\n  const getDirs = path => join(path).split(/[\\\\/]/).slice(0, -1).reduce((set, path) => set.length ? set.concat(join(set[set.length - 1], path)) : [path], []); // functions currently running\n\n\n  const running = new Set(); // return the queues for each path the function cares about\n  // fn => {paths, dirs}\n\n  const getQueues = fn => {\n    const res = reservations.get(fn);\n    /* istanbul ignore if - unpossible */\n\n    if (!res) throw new Error('function does not have any path reservations');\n    return {\n      paths: res.paths.map(path => queues.get(path)),\n      dirs: [...res.dirs].map(path => queues.get(path))\n    };\n  }; // check if fn is first in line for all its paths, and is\n  // included in the first set for all its dir queues\n\n\n  const check = fn => {\n    const {\n      paths,\n      dirs\n    } = getQueues(fn);\n    return paths.every(q => q[0] === fn) && dirs.every(q => q[0] instanceof Set && q[0].has(fn));\n  }; // run the function if it's first in line and not already running\n\n\n  const run = fn => {\n    if (running.has(fn) || !check(fn)) return false;\n    running.add(fn);\n    fn(() => clear(fn));\n    return true;\n  };\n\n  const clear = fn => {\n    if (!running.has(fn)) return false;\n    const {\n      paths,\n      dirs\n    } = reservations.get(fn);\n    const next = new Set();\n    paths.forEach(path => {\n      const q = queues.get(path);\n      assert.equal(q[0], fn);\n      if (q.length === 1) queues.delete(path);else {\n        q.shift();\n        if (typeof q[0] === 'function') next.add(q[0]);else q[0].forEach(fn => next.add(fn));\n      }\n    });\n    dirs.forEach(dir => {\n      const q = queues.get(dir);\n      assert(q[0] instanceof Set);\n      if (q[0].size === 1 && q.length === 1) queues.delete(dir);else if (q[0].size === 1) {\n        q.shift(); // must be a function or else the Set would've been reused\n\n        next.add(q[0]);\n      } else q[0].delete(fn);\n    });\n    running.delete(fn);\n    next.forEach(fn => run(fn));\n    return true;\n  };\n\n  const reserve = (paths, fn) => {\n    const dirs = new Set(paths.map(path => getDirs(path)).reduce((a, b) => a.concat(b)));\n    reservations.set(fn, {\n      dirs,\n      paths\n    });\n    paths.forEach(path => {\n      const q = queues.get(path);\n      if (!q) queues.set(path, [fn]);else q.push(fn);\n    });\n    dirs.forEach(dir => {\n      const q = queues.get(dir);\n      if (!q) queues.set(dir, [new Set([fn])]);else if (q[q.length - 1] instanceof Set) q[q.length - 1].add(fn);else q.push(new Set([fn]));\n    });\n    return run(fn);\n  };\n\n  return {\n    check,\n    reserve\n  };\n};","map":{"version":3,"sources":["E:/Important/FIT/project-front-end/FrontEnd_ThayLong_Nhom-21/app-chat/node_modules/tar/lib/path-reservations.js"],"names":["assert","require","module","exports","queues","Map","reservations","join","getDirs","path","split","slice","reduce","set","length","concat","running","Set","getQueues","fn","res","get","Error","paths","map","dirs","check","every","q","has","run","add","clear","next","forEach","equal","delete","shift","dir","size","reserve","a","b","push"],"mappings":"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","sourcesContent":["// A path exclusive reservation system\r\n// reserve([list, of, paths], fn)\r\n// When the fn is first in line for all its paths, it\r\n// is called with a cb that clears the reservation.\r\n//\r\n// Used by async unpack to avoid clobbering paths in use,\r\n// while still allowing maximal safe parallelization.\r\n\r\nconst assert = require('assert')\r\n\r\nmodule.exports = () => {\r\n  // path => [function or Set]\r\n  // A Set object means a directory reservation\r\n  // A fn is a direct reservation on that path\r\n  const queues = new Map()\r\n\r\n  // fn => {paths:[path,...], dirs:[path, ...]}\r\n  const reservations = new Map()\r\n\r\n  // return a set of parent dirs for a given path\r\n  const { join } = require('path')\r\n  const getDirs = path =>\r\n    join(path).split(/[\\\\/]/).slice(0, -1).reduce((set, path) =>\r\n      set.length ? set.concat(join(set[set.length - 1], path)) : [path], [])\r\n\r\n  // functions currently running\r\n  const running = new Set()\r\n\r\n  // return the queues for each path the function cares about\r\n  // fn => {paths, dirs}\r\n  const getQueues = fn => {\r\n    const res = reservations.get(fn)\r\n    /* istanbul ignore if - unpossible */\r\n    if (!res)\r\n      throw new Error('function does not have any path reservations')\r\n    return {\r\n      paths: res.paths.map(path => queues.get(path)),\r\n      dirs: [...res.dirs].map(path => queues.get(path)),\r\n    }\r\n  }\r\n\r\n  // check if fn is first in line for all its paths, and is\r\n  // included in the first set for all its dir queues\r\n  const check = fn => {\r\n    const {paths, dirs} = getQueues(fn)\r\n    return paths.every(q => q[0] === fn) &&\r\n      dirs.every(q => q[0] instanceof Set && q[0].has(fn))\r\n  }\r\n\r\n  // run the function if it's first in line and not already running\r\n  const run = fn => {\r\n    if (running.has(fn) || !check(fn))\r\n      return false\r\n    running.add(fn)\r\n    fn(() => clear(fn))\r\n    return true\r\n  }\r\n\r\n  const clear = fn => {\r\n    if (!running.has(fn))\r\n      return false\r\n\r\n    const { paths, dirs } = reservations.get(fn)\r\n    const next = new Set()\r\n\r\n    paths.forEach(path => {\r\n      const q = queues.get(path)\r\n      assert.equal(q[0], fn)\r\n      if (q.length === 1)\r\n        queues.delete(path)\r\n      else {\r\n        q.shift()\r\n        if (typeof q[0] === 'function')\r\n          next.add(q[0])\r\n        else\r\n          q[0].forEach(fn => next.add(fn))\r\n      }\r\n    })\r\n\r\n    dirs.forEach(dir => {\r\n      const q = queues.get(dir)\r\n      assert(q[0] instanceof Set)\r\n      if (q[0].size === 1 && q.length === 1)\r\n        queues.delete(dir)\r\n      else if (q[0].size === 1) {\r\n        q.shift()\r\n\r\n        // must be a function or else the Set would've been reused\r\n        next.add(q[0])\r\n      } else\r\n        q[0].delete(fn)\r\n    })\r\n    running.delete(fn)\r\n\r\n    next.forEach(fn => run(fn))\r\n    return true\r\n  }\r\n\r\n  const reserve = (paths, fn) => {\r\n    const dirs = new Set(\r\n      paths.map(path => getDirs(path)).reduce((a, b) => a.concat(b))\r\n    )\r\n    reservations.set(fn, {dirs, paths})\r\n    paths.forEach(path => {\r\n      const q = queues.get(path)\r\n      if (!q)\r\n        queues.set(path, [fn])\r\n      else\r\n        q.push(fn)\r\n    })\r\n    dirs.forEach(dir => {\r\n      const q = queues.get(dir)\r\n      if (!q)\r\n        queues.set(dir, [new Set([fn])])\r\n      else if (q[q.length - 1] instanceof Set)\r\n        q[q.length - 1].add(fn)\r\n      else\r\n        q.push(new Set([fn]))\r\n    })\r\n\r\n    return run(fn)\r\n  }\r\n\r\n  return { check, reserve }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}