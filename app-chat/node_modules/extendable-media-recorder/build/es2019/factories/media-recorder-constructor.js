export const createMediaRecorderConstructor = (createNativeMediaRecorder, createNotSupportedError, createWebAudioMediaRecorder, createWebmPcmMediaRecorder, encoderRegexes, eventTargetConstructor, nativeMediaRecorderConstructor) => {
    return class MediaRecorder extends eventTargetConstructor {
        constructor(stream, options = {}) {
            const { mimeType } = options;
            if (nativeMediaRecorderConstructor !== null &&
                // Bug #10: Safari does not yet implement the isTypeSupported() method.
                (mimeType === undefined ||
                    (nativeMediaRecorderConstructor.isTypeSupported !== undefined &&
                        nativeMediaRecorderConstructor.isTypeSupported(mimeType)))) {
                const internalMediaRecorder = createNativeMediaRecorder(nativeMediaRecorderConstructor, stream, options);
                super(internalMediaRecorder);
                this._internalMediaRecorder = internalMediaRecorder;
            }
            else if (mimeType !== undefined && encoderRegexes.some((regex) => regex.test(mimeType))) {
                super();
                // Bug #10: Safari does not yet implement the isTypeSupported() method.
                if (nativeMediaRecorderConstructor !== null &&
                    nativeMediaRecorderConstructor.isTypeSupported !== undefined &&
                    nativeMediaRecorderConstructor.isTypeSupported('audio/webm;codecs=pcm')) {
                    this._internalMediaRecorder = createWebmPcmMediaRecorder(this, nativeMediaRecorderConstructor, stream, mimeType);
                }
                else {
                    this._internalMediaRecorder = createWebAudioMediaRecorder(this, stream, mimeType);
                }
            }
            else {
                // This is creating a native MediaRecorder just to provoke it to throw an error.
                if (nativeMediaRecorderConstructor !== null) {
                    createNativeMediaRecorder(nativeMediaRecorderConstructor, stream, options);
                }
                throw createNotSupportedError();
            }
            this._ondataavailable = null;
            this._onerror = null;
            this._onstop = null;
        }
        get mimeType() {
            return this._internalMediaRecorder.mimeType;
        }
        get ondataavailable() {
            return this._ondataavailable === null ? this._ondataavailable : this._ondataavailable[0];
        }
        set ondataavailable(value) {
            if (this._ondataavailable !== null) {
                this.removeEventListener('dataavailable', this._ondataavailable[1]);
            }
            if (typeof value === 'function') {
                const boundListener = value.bind(this);
                this.addEventListener('dataavailable', boundListener);
                this._ondataavailable = [value, boundListener];
            }
            else {
                this._ondataavailable = null;
            }
        }
        get onerror() {
            return this._onerror === null ? this._onerror : this._onerror[0];
        }
        set onerror(value) {
            if (this._onerror !== null) {
                this.removeEventListener('error', this._onerror[1]);
            }
            if (typeof value === 'function') {
                const boundListener = value.bind(this);
                this.addEventListener('error', boundListener);
                this._onerror = [value, boundListener];
            }
            else {
                this._onerror = null;
            }
        }
        get onstop() {
            return this._onstop === null ? this._onstop : this._onstop[0];
        }
        set onstop(value) {
            if (this._onstop !== null) {
                this.removeEventListener('stop', this._onstop[1]);
            }
            if (typeof value === 'function') {
                const boundListener = value.bind(this);
                this.addEventListener('stop', boundListener);
                this._onstop = [value, boundListener];
            }
            else {
                this._onstop = null;
            }
        }
        get state() {
            return this._internalMediaRecorder.state;
        }
        start(timeslice) {
            return this._internalMediaRecorder.start(timeslice);
        }
        stop() {
            return this._internalMediaRecorder.stop();
        }
        static isTypeSupported(mimeType) {
            return ((nativeMediaRecorderConstructor !== null &&
                // Bug #10: Safari does not yet implement the isTypeSupported() method.
                nativeMediaRecorderConstructor.isTypeSupported !== undefined &&
                nativeMediaRecorderConstructor.isTypeSupported(mimeType)) ||
                encoderRegexes.some((regex) => regex.test(mimeType)));
        }
    };
};
//# sourceMappingURL=media-recorder-constructor.js.map