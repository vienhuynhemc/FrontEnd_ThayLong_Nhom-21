import { generateUniqueNumber } from 'fast-unique-numbers';
import { isSupported } from 'worker-factory';
import { worklet } from './worklet/worklet';
/*
 * @todo Explicitly referencing the barrel file seems to be necessary when enabling the
 * isolatedModules compiler option.
 */
export * from './interfaces/index';
export * from './types/index';
const blob = new Blob([worklet], { type: 'application/javascript; charset=utf-8' });
export const addRecorderAudioWorkletModule = async (addAudioWorkletModule) => {
    const url = URL.createObjectURL(blob);
    try {
        await addAudioWorkletModule(url);
    }
    finally {
        URL.revokeObjectURL(url);
    }
};
export function createRecorderAudioWorkletNode(audioWorkletNodeConstructor, context, options = {}) {
    const audioWorkletNode = new audioWorkletNodeConstructor(context, 'recorder-audio-worklet-processor', {
        ...options,
        channelCountMode: 'explicit',
        numberOfInputs: 1,
        numberOfOutputs: 0
    });
    const ongoingRequests = new Map();
    const listener = ({ data: message }) => {
        const { id } = message;
        if (id !== null && ongoingRequests.has(id)) {
            const { reject, resolve } = ongoingRequests.get(id);
            ongoingRequests.delete(id);
            if (message.error === undefined) {
                resolve(message.result);
            }
            else {
                reject(new Error(message.error.message));
            }
        }
    };
    const postMessage = ((port) => {
        return (message, transferables = []) => {
            return new Promise((resolve, reject) => {
                const id = generateUniqueNumber(ongoingRequests);
                ongoingRequests.set(id, { reject, resolve });
                port.postMessage({ id, ...message }, transferables);
            });
        };
    })(audioWorkletNode.port);
    const removeEventListener = ((port) => {
        port.addEventListener('message', listener);
        port.start();
        return () => port.removeEventListener('message', listener);
    })(audioWorkletNode.port);
    let state = 'inactive';
    const changeState = (expectedState, nextState) => {
        if (state !== expectedState) {
            throw new Error(`Expected the state to be "${expectedState}" but it was "${state}".`);
        }
        state = nextState;
    };
    Object.defineProperties(audioWorkletNode, {
        port: {
            get() {
                throw new Error("The port of a RecorderAudioWorkletNode can't be accessed.");
            }
        },
        record: {
            get() {
                return async (encoderPort) => {
                    changeState('inactive', 'recording');
                    return postMessage({
                        method: 'record',
                        params: { encoderPort }
                    }, [encoderPort]);
                };
            }
        },
        stop: {
            get() {
                return async () => {
                    changeState('recording', 'stopped');
                    try {
                        await postMessage({ method: 'stop' });
                    }
                    finally {
                        removeEventListener();
                    }
                };
            }
        }
    });
    return audioWorkletNode;
}
export { isSupported };
//# sourceMappingURL=module.js.map